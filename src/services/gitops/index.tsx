/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'
export const SPEC_VERSION = '1.0'
export type AgentQueryAgentSortByOptions = 'SORT_BY_NOT_SET' | 'NAME' | 'HEALTH_STATUS' | 'CONNECTIVITY_STATUS'

export type ApplicationQueryApplicationSortByOptions =
  | 'SORT_BY_NOT_SET'
  | 'NAME'
  | 'GITOPS_AGENT'
  | 'SOURCE'
  | 'DESTINATION'

export type ClusterQueryClusterSortByOptions =
  | 'SORT_BY_NOT_SET'
  | 'NAME'
  | 'GITOPS_AGENT'
  | 'URL'
  | 'VERSION'
  | 'CONNECTIVITY_STATUS'

export type OCIRepoTypeResponseOCIRepoTypeEnum = 'UNSET' | 'AWS' | 'GOOGLE' | 'GITHUB' | 'DOCKERHUB'

export type RepoListReqRepoSortByOptions = 'SORT_BY_NOT_SET' | 'NAME' | 'CONNECTIVITY_STATUS' | 'TYPE' | 'REPOSITORY'

export interface ApplicationsApplication {
  metadata?: V1ObjectMeta
  operation?: ApplicationsOperation
  spec?: ApplicationsApplicationSpec
  status?: ApplicationsApplicationStatus
}

export interface ApplicationsApplicationCondition {
  lastTransitionTime?: V1Time
  lastTransitionTimeTs?: string
  message?: string
  type?: string
}

export interface ApplicationsApplicationCreateRequest {
  application?: ApplicationsApplication
  isPLG?: boolean
  project?: string
  upsert?: boolean
  validate?: boolean
}

export interface ApplicationsApplicationDeleteRequest {
  cascade?: boolean
  name?: string
  propagationPolicy?: string
}

export interface ApplicationsApplicationDestination {
  name?: string
  namespace?: string
  server?: string
}

export interface ApplicationsApplicationList {
  items?: ApplicationsApplication[]
  metadata?: V1ListMeta
}

export interface ApplicationsApplicationManifestQuery {
  name?: string
  revision?: string
}

export interface ApplicationsApplicationPatchRequest {
  name?: string
  patch?: string
  patchType?: string
}

export interface ApplicationsApplicationPodLogsQuery {
  container?: string
  filter?: string
  follow?: boolean
  group?: string
  kind?: string
  name?: string
  namespace?: string
  podName?: string
  previous?: boolean
  resourceName?: string
  sinceSeconds?: string
  sinceTime?: V1Time
  tailLines?: string
  untilTime?: string
}

export interface ApplicationsApplicationQuery {
  name?: string
  project?: string[]
  refresh?: string
  repo?: string
  /**
   * when specified with a watch call, shows changes that occur after that particular version of a resource.
   */
  resourceVersion?: string
  selector?: string
}

export interface ApplicationsApplicationResourceDeleteRequest {
  force?: boolean
  group?: string
  kind?: string
  name?: string
  namespace?: string
  orphan?: boolean
  resourceName?: string
  version?: string
}

export interface ApplicationsApplicationResourceEventsQuery {
  name?: string
  resourceName?: string
  resourceNamespace?: string
  resourceUID?: string
}

export interface ApplicationsApplicationResourcePatchRequest {
  group?: string
  kind?: string
  name?: string
  namespace?: string
  patch?: string
  patchType?: string
  resourceName?: string
  version?: string
}

export interface ApplicationsApplicationResourceRequest {
  group?: string
  kind?: string
  name?: string
  namespace?: string
  resourceName?: string
  version?: string
}

export interface ApplicationsApplicationResourceResponse {
  manifest?: string
}

export interface ApplicationsApplicationResponse {
  [key: string]: any
}

export interface ApplicationsApplicationRollbackRequest {
  dryRun?: boolean
  id?: string
  name?: string
  prune?: boolean
}

export interface ApplicationsApplicationSource {
  /**
   * Chart is a Helm chart name, and must be specified for applications sourced from a Helm repo.
   */
  chart?: string
  directory?: ApplicationsApplicationSourceDirectory
  helm?: ApplicationsApplicationSourceHelm
  ksonnet?: ApplicationsApplicationSourceKsonnet
  kustomize?: ApplicationsApplicationSourceKustomize
  /**
   * Path is a directory path within the Git repository, and is only valid for applications sourced from Git.
   */
  path?: string
  plugin?: ApplicationsApplicationSourcePlugin
  repoURL?: string
  /**
   * TargetRevision defines the revision of the source to sync the application to.
   * In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD.
   * In case of Helm, this is a semver tag for the Chart's version.
   */
  targetRevision?: string
}

export interface ApplicationsApplicationSourceDirectory {
  exclude?: string
  include?: string
  jsonnet?: ApplicationsApplicationSourceJsonnet
  recurse?: boolean
}

export interface ApplicationsApplicationSourceHelm {
  fileParameters?: ApplicationsHelmFileParameter[]
  parameters?: ApplicationsHelmParameter[]
  passCredentials?: boolean
  releaseName?: string
  valueFiles?: string[]
  values?: string
  version?: string
}

export interface ApplicationsApplicationSourceJsonnet {
  extVars?: ApplicationsJsonnetVar[]
  libs?: string[]
  tlas?: ApplicationsJsonnetVar[]
}

export interface ApplicationsApplicationSourceKsonnet {
  environment?: string
  parameters?: ApplicationsKsonnetParameter[]
}

export interface ApplicationsApplicationSourceKustomize {
  commonAnnotations?: {
    [key: string]: string
  }
  commonLabels?: {
    [key: string]: string
  }
  forceCommonAnnotations?: boolean
  forceCommonLabels?: boolean
  images?: string[]
  namePrefix?: string
  nameSuffix?: string
  version?: string
}

export interface ApplicationsApplicationSourcePlugin {
  env?: ApplicationsEnvEntry[]
  name?: string
}

/**
 * ApplicationSpec represents desired application state. Contains link to repository with application definition and additional parameters link definition revision.
 */
export interface ApplicationsApplicationSpec {
  destination?: ApplicationsApplicationDestination
  ignoreDifferences?: ApplicationsResourceIgnoreDifferences[]
  info?: ApplicationsInfo[]
  /**
   * Project is a reference to the project this application belongs to.
   * The empty string means that application belongs to the 'default' project.
   */
  project?: string
  /**
   * RevisionHistoryLimit limits the number of items kept in the application's revision history, which is used for informational purposes as well as for rollbacks to previous versions.
   * This should only be changed in exceptional circumstances.
   * Setting to zero will store no history. This will reduce storage used.
   * Increasing will increase the space used to store the history, so we do not recommend increasing it.
   * Default is 10.
   */
  revisionHistoryLimit?: string
  source?: ApplicationsApplicationSource
  syncPolicy?: ApplicationsSyncPolicy
}

export interface ApplicationsApplicationStatus {
  conditions?: ApplicationsApplicationCondition[]
  health?: ApplicationsHealthStatus
  history?: ApplicationsRevisionHistory[]
  observedAt?: V1Time
  operationState?: ApplicationsOperationState
  reconciledAt?: V1Time
  resources?: ApplicationsResourceStatus[]
  sourceType?: string
  summary?: ApplicationsApplicationSummary
  sync?: ApplicationsSyncStatus
}

export interface ApplicationsApplicationSummary {
  /**
   * ExternalURLs holds all external URLs of application child resources.
   */
  externalURLs?: string[]
  /**
   * Images holds all images of application child resources.
   */
  images?: string[]
}

export interface ApplicationsApplicationSyncRequest {
  dryRun?: boolean
  infos?: ApplicationsInfo[]
  manifests?: string[]
  name?: string
  prune?: boolean
  resources?: ApplicationsSyncOperationResource[]
  retryStrategy?: ApplicationsRetryStrategy
  revision?: string
  strategy?: ApplicationsSyncStrategy
  syncOptions?: ApplicationsSyncOptions
}

export interface ApplicationsApplicationSyncWindow {
  duration?: string
  kind?: string
  manualSync?: boolean
  schedule?: string
}

export interface ApplicationsApplicationSyncWindowsQuery {
  name?: string
}

export interface ApplicationsApplicationSyncWindowsResponse {
  activeWindows?: ApplicationsApplicationSyncWindow[]
  assignedWindows?: ApplicationsApplicationSyncWindow[]
  canSync?: boolean
}

export interface ApplicationsApplicationTree {
  hosts?: ApplicationsHostInfo[]
  /**
   * Nodes contains list of nodes which either directly managed by the application and children of directly managed nodes.
   */
  nodes?: ApplicationsResourceNode[]
  /**
   * OrphanedNodes contains if or orphaned nodes: nodes which are not managed by the app but in the same namespace. List is populated only if orphaned resources enabled in app project.
   */
  orphanedNodes?: ApplicationsResourceNode[]
}

export interface ApplicationsApplicationUpdateRequest {
  application?: ApplicationsApplication
  validate?: boolean
}

export interface ApplicationsApplicationUpdateSpecRequest {
  name?: string
  spec?: ApplicationsApplicationSpec
  validate?: boolean
}

/**
 * ApplicationWatchEvent contains information about application change.
 */
export interface ApplicationsApplicationWatchEvent {
  application?: ApplicationsApplication
  type?: string
}

export interface ApplicationsBackoff {
  duration?: string
  factor?: string
  maxDuration?: string
}

export interface ApplicationsComparedTo {
  destination?: ApplicationsApplicationDestination
  source?: ApplicationsApplicationSource
}

export interface ApplicationsEnvEntry {
  name?: string
  value?: string
}

export interface ApplicationsEvent {
  action?: string
  count?: number
  eventTime?: V1MicroTime
  firstTimestamp?: V1Time
  firstTimestampTs?: string
  involvedObject?: ApplicationsObjectReference
  lastTimestamp?: V1Time
  lastTimestampTs?: string
  message?: string
  metadata?: V1ObjectMeta
  reason?: string
  related?: ApplicationsObjectReference
  reportingComponent?: string
  reportingInstance?: string
  series?: ApplicationsEventSeries
  source?: ApplicationsEventSource
  type?: string
}

/**
 * EventList is a list of events.
 */
export interface ApplicationsEventList {
  items?: ApplicationsEvent[]
  metadata?: V1ListMeta
}

/**
 * EventSeries contain information on series of events, i.e. thing that was/is happening
 * continuously for some time.
 */
export interface ApplicationsEventSeries {
  count?: number
  lastObservedTime?: V1MicroTime
}

export interface ApplicationsEventSource {
  component?: string
  host?: string
}

export interface ApplicationsHealthStatus {
  message?: string
  status?: string
}

export interface ApplicationsHelmFileParameter {
  name?: string
  path?: string
}

export interface ApplicationsHelmParameter {
  forceString?: boolean
  name?: string
  value?: string
}

export interface ApplicationsHostInfo {
  name?: string
  resourcesInfo?: ApplicationsHostResourceInfo[]
  systemInfo?: V1NodeSystemInfo
}

export interface ApplicationsHostResourceInfo {
  capacity?: string
  requestedByApp?: string
  requestedByNeighbors?: string
  resourceName?: string
}

export interface ApplicationsInfo {
  name?: string
  value?: string
}

export interface ApplicationsInfoItem {
  /**
   * Name is a human readable title for this piece of information.
   */
  name?: string
  /**
   * Value is human readable content.
   */
  value?: string
}

export interface ApplicationsJsonnetVar {
  code?: boolean
  name?: string
  value?: string
}

export interface ApplicationsKsonnetParameter {
  component?: string
  name?: string
  value?: string
}

export interface ApplicationsLogEntry {
  content?: string
  last?: boolean
  podName?: string
  timeStamp?: V1Time
  timeStampStr?: string
}

export interface ApplicationsManagedResourcesResponse {
  items?: ApplicationsResourceDiff[]
}

export interface ApplicationsObjectReference {
  apiVersion?: string
  fieldPath?: string
  kind?: string
  name?: string
  namespace?: string
  resourceVersion?: string
  uid?: string
}

export interface ApplicationsOperation {
  info?: ApplicationsInfo[]
  initiatedBy?: ApplicationsOperationInitiator
  retry?: ApplicationsRetryStrategy
  sync?: ApplicationsSyncOperation
}

export interface ApplicationsOperationInitiator {
  /**
   * Automated is set to true if operation was initiated automatically by the application controller.
   */
  automated?: boolean
  username?: string
}

export interface ApplicationsOperationState {
  finishedAt?: V1Time
  finishedAtTs?: string
  /**
   * Message holds any pertinent messages when attempting to perform operation (typically errors).
   */
  message?: string
  operation?: ApplicationsOperation
  phase?: string
  retryCount?: string
  startedAt?: V1Time
  startedAtTs?: string
  syncResult?: ApplicationsSyncOperationResult
}

export interface ApplicationsOperationTerminateRequest {
  name?: string
}

export interface ApplicationsOperationTerminateResponse {
  [key: string]: any
}

export interface ApplicationsResourceAction {
  disabled?: boolean
  name?: string
  params?: ApplicationsResourceActionParam[]
}

export interface ApplicationsResourceActionParam {
  default?: string
  name?: string
  type?: string
  value?: string
}

export interface ApplicationsResourceActionRunRequest {
  action?: string
  group?: string
  kind?: string
  name?: string
  namespace?: string
  resourceName?: string
  version?: string
}

export interface ApplicationsResourceActionsListResponse {
  actions?: ApplicationsResourceAction[]
}

export interface ApplicationsResourceDiff {
  diff?: string
  group?: string
  hook?: boolean
  kind?: string
  liveState?: string
  modified?: boolean
  name?: string
  namespace?: string
  normalizedLiveState?: string
  predictedLiveState?: string
  resourceVersion?: string
  targetState?: string
}

/**
 * ResourceIgnoreDifferences contains resource filter and list of json paths which should be ignored during comparison with live state.
 */
export interface ApplicationsResourceIgnoreDifferences {
  group?: string
  jqPathExpressions?: string[]
  jsonPointers?: string[]
  kind?: string
  managedFieldsManagers?: string[]
  name?: string
  namespace?: string
}

export interface ApplicationsResourceNetworkingInfo {
  /**
   * ExternalURLs holds list of URLs which should be available externally. List is populated for ingress resources using rules hostnames.
   */
  externalURLs?: string[]
  ingress?: V1LoadBalancerIngress[]
  labels?: {
    [key: string]: string
  }
  targetLabels?: {
    [key: string]: string
  }
  targetRefs?: ApplicationsResourceRef[]
}

export interface ApplicationsResourceNode {
  createdAt?: V1Time
  health?: ApplicationsHealthStatus
  images?: string[]
  info?: ApplicationsInfoItem[]
  networkingInfo?: ApplicationsResourceNetworkingInfo
  parentRefs?: ApplicationsResourceRef[]
  resourceRef?: ApplicationsResourceRef
  resourceVersion?: string
}

export interface ApplicationsResourceRef {
  group?: string
  kind?: string
  name?: string
  namespace?: string
  uid?: string
  version?: string
}

export interface ApplicationsResourceResult {
  group?: string
  /**
   * HookPhase contains the state of any operation associated with this resource OR hook
   * This can also contain values for non-hook resources.
   */
  hookPhase?: string
  hookType?: string
  kind?: string
  message?: string
  name?: string
  namespace?: string
  status?: string
  syncPhase?: string
  version?: string
}

export interface ApplicationsResourceStatus {
  group?: string
  health?: ApplicationsHealthStatus
  hook?: boolean
  kind?: string
  name?: string
  namespace?: string
  requiresPruning?: boolean
  status?: string
  version?: string
}

export interface ApplicationsResourcesQuery {
  applicationName?: string
  group?: string
  kind?: string
  name?: string
  namespace?: string
  version?: string
}

export interface ApplicationsRetryStrategy {
  backoff?: ApplicationsBackoff
  /**
   * Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
   */
  limit?: string
}

export interface ApplicationsRevisionHistory {
  deployStartedAt?: V1Time
  deployedAt?: V1Time
  id?: string
  revision?: string
  source?: ApplicationsApplicationSource
}

export interface ApplicationsRevisionMetadataQuery {
  name?: string
  revision?: string
}

/**
 * SyncOperation contains details about a sync operation.
 */
export interface ApplicationsSyncOperation {
  dryRun?: boolean
  manifests?: string[]
  prune?: boolean
  resources?: ApplicationsSyncOperationResource[]
  /**
   * Revision is the revision (Git) or chart version (Helm) which to sync the application to
   * If omitted, will use the revision specified in app spec.
   */
  revision?: string
  source?: ApplicationsApplicationSource
  syncOptions?: string[]
  syncStrategy?: ApplicationsSyncStrategy
}

/**
 * SyncOperationResource contains resources to sync.
 */
export interface ApplicationsSyncOperationResource {
  group?: string
  kind?: string
  name?: string
  namespace?: string
}

export interface ApplicationsSyncOperationResult {
  resources?: ApplicationsResourceResult[]
  revision?: string
  source?: ApplicationsApplicationSource
}

export interface ApplicationsSyncOptions {
  items?: string[]
}

export interface ApplicationsSyncPolicy {
  automated?: ApplicationsSyncPolicyAutomated
  retry?: ApplicationsRetryStrategy
  syncOptions?: string[]
}

export interface ApplicationsSyncPolicyAutomated {
  allowEmpty?: boolean
  prune?: boolean
  selfHeal?: boolean
}

export interface ApplicationsSyncStatus {
  comparedTo?: ApplicationsComparedTo
  revision?: string
  status?: string
}

export interface ApplicationsSyncStrategy {
  apply?: ApplicationsSyncStrategyApply
  hook?: ApplicationsSyncStrategyHook
}

export interface ApplicationsSyncStrategyApply {
  /**
   * Force indicates whether or not to supply the --force flag to `kubectl apply`.
   * The --force flag deletes and re-create the resource, when PATCH encounters conflict and has
   * retried for 5 times.
   */
  force?: boolean
}

/**
 * SyncStrategyHook will perform a sync using hooks annotations.
 * If no hook annotation is specified falls back to `kubectl apply`.
 */
export interface ApplicationsSyncStrategyHook {
  syncStrategyApply?: ApplicationsSyncStrategyApply
}

export interface Applicationv1alpha1RepositoryCertificate {
  certData?: string
  certInfo?: string
  certSubType?: string
  certType?: string
  serverName?: string
}

export interface Applicationv1alpha1RepositoryCertificateList {
  items?: Applicationv1alpha1RepositoryCertificate[]
  metadata?: V1ListMeta
}

export interface AppprojectsAppProject {
  metadata?: V1ObjectMeta
  spec?: AppprojectsAppProjectSpec
  status?: AppprojectsAppProjectStatus
}

export interface AppprojectsAppProjectList {
  items?: AppprojectsAppProject[]
  metadata?: V1ListMeta
}

export interface AppprojectsAppProjectSpec {
  clusterResourceBlacklist?: V1GroupKind[]
  clusterResourceWhitelist?: V1GroupKind[]
  description?: string
  destinations?: AppprojectsApplicationDestination[]
  namespaceResourceBlacklist?: V1GroupKind[]
  namespaceResourceWhitelist?: V1GroupKind[]
  orphanedResources?: AppprojectsOrphanedResourcesMonitorSettings
  roles?: AppprojectsProjectRole[]
  signatureKeys?: AppprojectsSignatureKey[]
  sourceRepos?: string[]
  syncWindows?: AppprojectsSyncWindow[]
}

export interface AppprojectsAppProjectStatus {
  jwtTokensByRole?: {
    [key: string]: AppprojectsJWTTokens
  }
}

export interface AppprojectsApplicationDestination {
  name?: string
  namespace?: string
  server?: string
}

export interface AppprojectsJWTToken {
  exp?: string
  iat?: string
  id?: string
}

export interface AppprojectsJWTTokens {
  items?: AppprojectsJWTToken[]
}

export interface AppprojectsOrphanedResourceKey {
  group?: string
  kind?: string
  name?: string
}

export interface AppprojectsOrphanedResourcesMonitorSettings {
  ignore?: AppprojectsOrphanedResourceKey[]
  warn?: boolean
}

export interface AppprojectsProjectRole {
  description?: string
  groups?: string[]
  jwtTokens?: AppprojectsJWTToken[]
  name?: string
  policies?: string[]
}

export interface AppprojectsSignatureKey {
  keyID?: string
}

export interface AppprojectsSyncWindow {
  applications?: string[]
  clusters?: string[]
  duration?: string
  kind?: string
  manualSync?: boolean
  namespaces?: string[]
  schedule?: string
  timeZone?: string
}

export interface CertificateRepositoryCertificateCreateRequest {
  certificates?: Applicationv1alpha1RepositoryCertificateList
  upsert?: boolean
}

export interface CertificateRepositoryCertificateQuery {
  certSubType?: string
  certType?: string
  hostNamePattern?: string
}

export interface CertificatesRepositoryCertificate {
  certData?: string
  certInfo?: string
  certSubType?: string
  certType?: string
  serverName?: string
}

export interface CertificatesRepositoryCertificateList {
  items?: CertificatesRepositoryCertificate[]
  metadata?: V1ListMeta
}

export interface ClustersAWSAuthConfig {
  clusterName?: string
  /**
   * RoleARN contains optional role ARN. If set then AWS IAM Authenticator assume a role to perform cluster operations instead of the default AWS credential provider chain.
   */
  roleARN?: string
}

export interface ClustersCluster {
  annotations?: {
    [key: string]: string
  }
  /**
   * Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
   */
  clusterResources?: boolean
  config?: ClustersClusterConfig
  connectionState?: CommonsConnectionState
  info?: ClustersClusterInfo
  labels?: {
    [key: string]: string
  }
  name?: string
  /**
   * Holds list of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
   */
  namespaces?: string[]
  project?: string
  refreshRequestedAt?: V1Time
  refreshRequestedAtTs?: string
  server?: string
  serverVersion?: string
  /**
   * Shard contains optional shard number. Calculated on the fly by the application controller if not specified.
   */
  shard?: string
  type?: ClustersClusterType
}

export interface ClustersClusterCacheInfo {
  apisCount?: string
  lastCacheSyncTime?: V1Time
  lastCacheSyncTimeTs?: string
  resourcesCount?: string
}

/**
 * ClusterConfig is the configuration attributes. This structure is subset of the go-client
 * rest.Config with annotations added for marshalling.
 */
export interface ClustersClusterConfig {
  awsAuthConfig?: ClustersAWSAuthConfig
  /**
   * AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
   */
  awsClusterName?: string
  /**
   * Server requires Bearer authentication. This client will not attempt to use
   * refresh tokens for an OAuth2 flow.
   * TODO: demonstrate an OAuth2 compatible client.
   */
  bearerToken?: string
  clusterConnectionType?: string
  execProviderConfig?: ClustersExecProviderConfig
  password?: string
  /**
   * RoleARN contains optional role ARN. If set then AWS IAM Authenticator assume a role to perform cluster operations instead of the default AWS credential provider chain.
   */
  roleARN?: string
  tlsClientConfig?: ClustersTLSClientConfig
  username?: string
}

export interface ClustersClusterCreateRequest {
  cluster?: ClustersCluster
  tags?: {
    [key: string]: string
  }
  upsert?: boolean
}

export interface ClustersClusterID {
  type?: string
  value?: string
}

export interface ClustersClusterInfo {
  apiVersions?: string[]
  applicationsCount?: string
  cacheInfo?: ClustersClusterCacheInfo
  connectionState?: CommonsConnectionState
  serverVersion?: string
}

/**
 * ClusterList is a collection of Clusters.
 */
export interface ClustersClusterList {
  items?: ClustersCluster[]
  metadata?: V1ListMeta
}

export interface ClustersClusterQuery {
  id?: ClustersClusterID
  name?: string
  project?: string
  server?: string
}

export interface ClustersClusterResponse {
  [key: string]: any
}

export type ClustersClusterType = 'CUSTOMER_PROVIDED' | 'HARNESS_HOSTED'

export interface ClustersClusterUpdateRequest {
  cluster?: ClustersCluster
  id?: ClustersClusterID
  tags?: {
    [key: string]: string
  }
  updateMask?: ProtobufFieldMask
  updatedFields?: string[]
}

export interface ClustersExecProviderConfig {
  apiVersion?: string
  args?: string[]
  command?: string
  env?: {
    [key: string]: string
  }
  installHint?: string
}

export interface ClustersTLSClientConfig {
  caData?: string
  certData?: string
  /**
   * Insecure specifies that the server should be accessed without verifying the TLS certificate. For testing only.
   */
  insecure?: boolean
  keyData?: string
  /**
   * ServerName is passed to the server for SNI and is used in the client to check server
   * certificates against. If ServerName is empty, the hostname used to contact the
   * server is used.
   */
  serverName?: string
}

export interface CommonsConnectionState {
  attemptedAt?: V1Time
  attemptedAtTs?: string
  message?: string
  status?: string
}

export interface GatewayruntimeError {
  code?: number
  details?: ProtobufAny[]
  error?: string
  message?: string
}

export interface GpgkeysGnuPGPublicKey {
  fingerprint?: string
  keyData?: string
  keyID?: string
  owner?: string
  subType?: string
  trust?: string
}

export interface GpgkeysGnuPGPublicKeyCreateRequest {
  publickey?: GpgkeysGnuPGPublicKey
  upsert?: boolean
}

export interface GpgkeysGnuPGPublicKeyCreateResponse {
  created?: GpgkeysGnuPGPublicKeyList
  skipped?: string[]
}

export interface GpgkeysGnuPGPublicKeyList {
  items?: GpgkeysGnuPGPublicKey[]
  metadata?: V1ListMeta
}

export interface GpgkeysGnuPGPublicKeyQuery {
  keyID?: string
}

export interface GpgkeysGnuPGPublicKeyResponse {
  [key: string]: any
}

export interface HrepocredsRepoCreds {
  enableOCI?: boolean
  githubAppEnterpriseBaseUrl?: string
  githubAppID?: string
  githubAppInstallationID?: string
  githubAppPrivateKey?: string
  name?: string
  password?: string
  sshPrivateKey?: string
  tlsClientCertData?: string
  tlsClientCertKey?: string
  /**
   * Type specifies the type of the repoCreds. Can be either "git" or "helm. "git" is assumed if empty or absent.
   */
  type?: string
  url?: string
  username?: string
}

export interface HrepocredsRepoCredsCreateRequest {
  creds?: HrepocredsRepoCreds
  upsert?: boolean
}

export interface HrepocredsRepoCredsQuery {
  repoCredsType?: string
  url?: string
}

export interface HrepocredsRepoCredsResponse {
  [key: string]: any
}

export interface HrepocredsRepoCredsUpdateRequest {
  creds?: HrepocredsRepoCreds
  updateMask?: ProtobufFieldMask
}

/**
 * +protobuf=true
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 * +k8s:openapi-gen=true
 */
export interface IntstrIntOrString {
  intVal?: number
  strVal?: string
  type?: string
}

export interface ProjectsEmptyResponse {
  [key: string]: any
}

/**
 * ProjectCreateRequest defines project creation parameters.
 */
export interface ProjectsProjectCreateRequest {
  project?: AppprojectsAppProject
  upsert?: boolean
}

export interface ProjectsProjectQuery {
  name?: string
}

export interface ProjectsProjectUpdateRequest {
  project?: AppprojectsAppProject
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *
 * Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 * Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
 * name "y.z".
 *
 *
 * JSON
 *
 * The JSON representation of an `Any` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field `@type` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       "@type": "type.googleapis.com/google.profile.Person",
 *       "firstName": <string>,
 *       "lastName": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * `value` which holds the custom JSON in addition to the `@type`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       "@type": "type.googleapis.com/google.protobuf.Duration",
 *       "value": "1.212s"
 *     }
 */
export interface ProtobufAny {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized
   * protocol buffer message. This string must contain at least
   * one "/" character. The last segment of the URL's path must represent
   * the fully qualified name of the type (as in
   * `path/google.protobuf.Duration`). The name should be in a canonical form
   * (e.g., leading "." is not accepted).
   *
   * In practice, teams usually precompile into the binary all types that they
   * expect it to use in the context of Any. However, for URLs which use the
   * scheme `http`, `https`, or no scheme, one can optionally set up a type
   * server that maps type URLs to message definitions as follows:
   *
   * * If no scheme is provided, `https` is assumed.
   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
   *   value in binary format, or produce an error.
   * * Applications are allowed to cache lookup results based on the
   *   URL, or have them precompiled into a binary to avoid any
   *   lookup. Therefore, binary compatibility needs to be preserved
   *   on changes to types. (Use versioned type names to manage
   *   breaking changes.)
   *
   * Note: this functionality is not currently available in the official
   * protobuf release, and it is not used for type URLs beginning with
   * type.googleapis.com.
   *
   * Schemes other than `http`, `https` (or the empty scheme) might be
   * used with implementation specific semantics.
   */
  type_url?: string
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   */
  value?: string
}

/**
 * paths: "f.a"
 *     paths: "f.b.d"
 *
 * Here `f` represents a field in some root message, `a` and `b`
 * fields in the message found in `f`, and `d` a field found in the
 * message in `f.b`.
 *
 * Field masks are used to specify a subset of fields that should be
 * returned by a get operation or modified by an update operation.
 * Field masks also have a custom JSON encoding (see below).
 *
 * # Field Masks in Projections
 *
 * When used in the context of a projection, a response message or
 * sub-message is filtered by the API to only contain those fields as
 * specified in the mask. For example, if the mask in the previous
 * example is applied to a response message as follows:
 *
 *     f {
 *       a : 22
 *       b {
 *         d : 1
 *         x : 2
 *       }
 *       y : 13
 *     }
 *     z: 8
 *
 * The result will not contain specific values for fields x,y and z
 * (their value will be set to the default, and omitted in proto text
 * output):
 *
 *
 *     f {
 *       a : 22
 *       b {
 *         d : 1
 *       }
 *     }
 *
 * A repeated field is not allowed except at the last position of a
 * paths string.
 *
 * If a FieldMask object is not present in a get operation, the
 * operation applies to all fields (as if a FieldMask of all fields
 * had been specified).
 *
 * Note that a field mask does not necessarily apply to the
 * top-level response message. In case of a REST get operation, the
 * field mask applies directly to the response, but in case of a REST
 * list operation, the mask instead applies to each individual message
 * in the returned resource list. In case of a REST custom method,
 * other definitions may be used. Where the mask applies will be
 * clearly documented together with its declaration in the API.  In
 * any case, the effect on the returned resource/resources is required
 * behavior for APIs.
 *
 * # Field Masks in Update Operations
 *
 * A field mask in update operations specifies which fields of the
 * targeted resource are going to be updated. The API is required
 * to only change the values of the fields as specified in the mask
 * and leave the others untouched. If a resource is passed in to
 * describe the updated values, the API ignores the values of all
 * fields not covered by the mask.
 *
 * If a repeated field is specified for an update operation, new values will
 * be appended to the existing repeated field in the target resource. Note that
 * a repeated field is only allowed in the last position of a `paths` string.
 *
 * If a sub-message is specified in the last position of the field mask for an
 * update operation, then new value will be merged into the existing sub-message
 * in the target resource.
 *
 * For example, given the target message:
 *
 *     f {
 *       b {
 *         d: 1
 *         x: 2
 *       }
 *       c: [1]
 *     }
 *
 * And an update message:
 *
 *     f {
 *       b {
 *         d: 10
 *       }
 *       c: [2]
 *     }
 *
 * then if the field mask is:
 *
 *  paths: ["f.b", "f.c"]
 *
 * then the result will be:
 *
 *     f {
 *       b {
 *         d: 10
 *         x: 2
 *       }
 *       c: [1, 2]
 *     }
 *
 * An implementation may provide options to override this default behavior for
 * repeated and message fields.
 *
 * In order to reset a field's value to the default, the field must
 * be in the mask and set to the default value in the provided resource.
 * Hence, in order to reset all fields of a resource, provide a default
 * instance of the resource and set all fields in the mask, or do
 * not provide a mask as described below.
 *
 * If a field mask is not present on update, the operation applies to
 * all fields (as if a field mask of all fields has been specified).
 * Note that in the presence of schema evolution, this may mean that
 * fields the client does not know and has therefore not filled into
 * the request will be reset to their default. If this is unwanted
 * behavior, a specific service may require a client to always specify
 * a field mask, producing an error if not.
 *
 * As with get operations, the location of the resource which
 * describes the updated values in the request message depends on the
 * operation kind. In any case, the effect of the field mask is
 * required to be honored by the API.
 *
 * ## Considerations for HTTP REST
 *
 * The HTTP kind of an update operation which uses a field mask must
 * be set to PATCH instead of PUT in order to satisfy HTTP semantics
 * (PUT must only be used for full updates).
 *
 * # JSON Encoding of Field Masks
 *
 * In JSON, a field mask is encoded as a single string where paths are
 * separated by a comma. Fields name in each path are converted
 * to/from lower-camel naming conventions.
 *
 * As an example, consider the following message declarations:
 *
 *     message Profile {
 *       User user = 1;
 *       Photo photo = 2;
 *     }
 *     message User {
 *       string display_name = 1;
 *       string address = 2;
 *     }
 *
 * In proto a field mask for `Profile` may look as such:
 *
 *     mask {
 *       paths: "user.display_name"
 *       paths: "photo"
 *     }
 *
 * In JSON, the same mask is represented as below:
 *
 *     {
 *       mask: "user.displayName,photo"
 *     }
 *
 * # Field Masks and Oneof Fields
 *
 * Field masks treat fields in oneofs just as regular fields. Consider the
 * following message:
 *
 *     message SampleMessage {
 *       oneof test_oneof {
 *         string name = 4;
 *         SubMessage sub_message = 9;
 *       }
 *     }
 *
 * The field mask can be:
 *
 *     mask {
 *       paths: "name"
 *     }
 *
 * Or:
 *
 *     mask {
 *       paths: "sub_message"
 *     }
 *
 * Note that oneof type names ("test_oneof" in this case) cannot be used in
 * paths.
 *
 * ## Field Mask Verification
 *
 * The implementation of any API method which has a FieldMask type field in the
 * request should verify the included field paths, and return an
 * `INVALID_ARGUMENT` error if any path is unmappable.
 */
export interface ProtobufFieldMask {
  /**
   * The set of field mask paths.
   */
  paths?: string[]
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
 * `Value` type union.
 *
 *  The JSON representation for `NullValue` is JSON `null`.
 *
 *  - NULL_VALUE: Null value.
 */
export type ProtobufNullValue = 'NULL_VALUE'

export interface ReconcilerReconcileCountsResponse {
  applicationCount?: number
  applicationPerProjectCount?: {
    [key: string]: number
  }
  clusterCount?: number
  clusterPerProjectCount?: {
    [key: string]: number
  }
  gnuPGPublicKeyCount?: number
  repoCredsCount?: number
  repositoryCertificateCount?: number
  repositoryCount?: number
  repositoryPerProjectCount?: {
    [key: string]: number
  }
}

export interface RepositoriesAWSSecretRef {
  awsAccessKeyID?: string
  awsSecretAccessKey?: string
  awsSessionToken?: string
}

export interface RepositoriesAppInfo {
  path?: string
  type?: string
}

export interface RepositoriesCheckESOResponse {
  esoPresent?: boolean
}

export interface RepositoriesDirectoryAppSpec {
  [key: string]: any
}

/**
 * ECRAuthorizationTokenSpec represents externalSecret for ECR External Secret Operator generator.
 */
export interface RepositoriesECRAuthorizationTokenGenerator {
  jwtAuth?: RepositoriesServiceAccountSelector
  region?: string
  role?: string
  secretRef?: RepositoriesAWSSecretRef
}

export interface RepositoriesESOGeneratorResponse {
  ecrGen?: RepositoriesECRAuthorizationTokenGenerator
  gcrGen?: RepositoriesGCRAccessTokenGenerator
  type?: RepositoriesESOGeneratorType
}

export type RepositoriesESOGeneratorType = 'UNSET' | 'AWS_ECR' | 'GOOGLE_GCR'

export interface RepositoriesGCRAccessTokenGenerator {
  accessKey?: string
  projectID?: string
  workloadIdentity?: RepositoriesGCRWorkloadIdentity
}

export interface RepositoriesGCRWorkloadIdentity {
  clusterLocation?: string
  clusterName?: string
  clusterProjectID?: string
  serviceAccountRef?: RepositoriesServiceAccountSelector
}

export interface RepositoriesHelmAppSpec {
  fileParameters?: ApplicationsHelmFileParameter[]
  name?: string
  parameters?: ApplicationsHelmParameter[]
  valueFiles?: string[]
  values?: string
}

export interface RepositoriesHelmChart {
  name?: string
  versions?: string[]
}

export interface RepositoriesHelmChartsResponse {
  items?: RepositoriesHelmChart[]
}

export interface RepositoriesKsonnetAppSpec {
  environments?: {
    [key: string]: RepositoriesKsonnetEnvironment
  }
  name?: string
  parameters?: ApplicationsKsonnetParameter[]
}

export interface RepositoriesKsonnetEnvironment {
  destination?: RepositoriesKsonnetEnvironmentDestination
  /**
   * KubernetesVersion is the kubernetes version the targeted cluster is running on.
   */
  k8sVersion?: string
  name?: string
}

export interface RepositoriesKsonnetEnvironmentDestination {
  namespace?: string
  /**
   * Server is the Kubernetes server that the cluster is running on.
   */
  server?: string
}

export interface RepositoriesKustomizeAppSpec {
  /**
   * images is a list of available images.
   */
  images?: string[]
}

export interface RepositoriesManifestResponse {
  manifests?: string[]
  namespace?: string
  revision?: string
  server?: string
  sourceType?: string
  verifyResult?: string
}

export interface RepositoriesRefs {
  branches?: string[]
  tags?: string[]
}

export interface RepositoriesRepoAccessQuery {
  connectionType?: string
  enableOci?: boolean
  githubAppEnterpriseBaseUrl?: string
  githubAppID?: string
  githubAppInstallationID?: string
  githubAppPrivateKey?: string
  insecure?: boolean
  name?: string
  password?: string
  project?: string
  proxy?: string
  repo?: string
  sshPrivateKey?: string
  tlsClientCertData?: string
  tlsClientCertKey?: string
  type?: string
  updateMask?: ProtobufFieldMask
  username?: string
}

export interface RepositoriesRepoAppDetailsQuery {
  appName?: string
  appProject?: string
  source?: ApplicationsApplicationSource
}

export interface RepositoriesRepoAppDetailsResponse {
  directory?: RepositoriesDirectoryAppSpec
  helm?: RepositoriesHelmAppSpec
  ksonnet?: RepositoriesKsonnetAppSpec
  kustomize?: RepositoriesKustomizeAppSpec
  type?: string
}

export interface RepositoriesRepoAppsQuery {
  appName?: string
  appProject?: string
  repo?: string
  revision?: string
}

export interface RepositoriesRepoAppsResponse {
  items?: RepositoriesAppInfo[]
}

export interface RepositoriesRepoCreateRequest {
  credsOnly?: boolean
  ecrGen?: RepositoriesECRAuthorizationTokenGenerator
  gcrGen?: RepositoriesGCRAccessTokenGenerator
  genType?: RepositoriesESOGeneratorType
  /**
   * refreshInterval in format 1s, 1m, 1h...
   */
  refreshInterval?: string
  repo?: RepositoriesRepository
  upsert?: boolean
}

export interface RepositoriesRepoQuery {
  forceRefresh?: boolean
  project?: string
  repo?: string
}

export interface RepositoriesRepoResponse {
  [key: string]: any
}

export interface RepositoriesRepoUpdateRequest {
  ecrGen?: RepositoriesECRAuthorizationTokenGenerator
  gcrGen?: RepositoriesGCRAccessTokenGenerator
  genType?: RepositoriesESOGeneratorType
  /**
   * refreshInterval in format 1s, 1m, 1h...
   */
  refreshInterval?: string
  repo?: RepositoriesRepository
  updateMask?: ProtobufFieldMask
}

export interface RepositoriesRepository {
  connectionState?: CommonsConnectionState
  connectionType?: string
  /**
   * EnableLFS specifies whether git-lfs support should be enabled for this repo. Only valid for Git repositories.
   */
  enableLfs?: boolean
  enableOCI?: boolean
  githubAppEnterpriseBaseUrl?: string
  githubAppID?: string
  githubAppInstallationID?: string
  githubAppPrivateKey?: string
  inheritedCreds?: boolean
  insecure?: boolean
  insecureIgnoreHostKey?: boolean
  name?: string
  password?: string
  project?: string
  proxy?: string
  repo?: string
  /**
   * SSHPrivateKey contains the PEM data for authenticating at the repo server. Only used with Git repos.
   */
  sshPrivateKey?: string
  tlsClientCertData?: string
  tlsClientCertKey?: string
  /**
   * Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
   */
  type?: string
  username?: string
}

/**
 * RepositoryList is a collection of Repositories.
 */
export interface RepositoriesRepositoryList {
  items?: RepositoriesRepository[]
  metadata?: V1ListMeta
}

export interface RepositoriesRevisionMetadata {
  author?: string
  date?: V1Time
  message?: string
  /**
   * SignatureInfo contains a hint on the signer if the revision was signed with GPG, and signature verification is enabled.
   */
  signatureInfo?: string
  tags?: string[]
}

export interface RepositoriesServiceAccountSelector {
  audiences?: string[]
  name?: string
  namespace?: string
}

/**
 * Quantity is a fixed-point representation of a number.
 * It provides convenient marshaling/unmarshaling in JSON and YAML,
 * in addition to String() and AsInt64() accessors.
 *
 * The serialization format is:
 *
 * <quantity>        ::= <signedNumber><suffix>
 *   (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
 * <digit>           ::= 0 | 1 | ... | 9
 * <digits>          ::= <digit> | <digit><digits>
 * <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits>
 * <sign>            ::= "+" | "-"
 * <signedNumber>    ::= <number> | <sign><number>
 * <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI>
 * <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
 *   (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
 * <decimalSI>       ::= m | "" | k | M | G | T | P | E
 *   (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
 * <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>
 *
 * No matter which of the three exponent forms is used, no quantity may represent
 * a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal
 * places. Numbers larger or more precise will be capped or rounded up.
 * (E.g.: 0.1m will rounded up to 1m.)
 * This may be extended in the future if we require larger or smaller quantities.
 *
 * When a Quantity is parsed from a string, it will remember the type of suffix
 * it had, and will use the same type again when it is serialized.
 *
 * Before serializing, Quantity will be put in "canonical form".
 * This means that Exponent/suffix will be adjusted up or down (with a
 * corresponding increase or decrease in Mantissa) such that:
 *   a. No precision is lost
 *   b. No fractional digits will be emitted
 *   c. The exponent (or suffix) is as large as possible.
 * The sign will be omitted unless the number is negative.
 *
 * Examples:
 *   1.5 will be serialized as "1500m"
 *   1.5Gi will be serialized as "1536Mi"
 *
 * Note that the quantity will NEVER be internally represented by a
 * floating point number. That is the whole point of this exercise.
 *
 * Non-canonical values will still parse as long as they are well formed,
 * but will be re-emitted in their canonical form. (So always use canonical
 * form, or don't diff.)
 *
 * This format is intended to make it difficult to use these numbers without
 * writing some sort of special handling code in the hopes that that will
 * cause implementors to also use a fixed point implementation.
 *
 * +protobuf=true
 * +protobuf.embed=string
 * +protobuf.options.marshal=false
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 * +k8s:deepcopy-gen=true
 * +k8s:openapi-gen=true
 */
export interface ResourceQuantity {
  string?: string
}

export interface RuntimeStreamError {
  details?: ProtobufAny[]
  grpc_code?: number
  http_code?: number
  http_status?: string
  message?: string
}

export interface Servicev1AppProjectMapping {
  appProjMap?: {
    [key: string]: Servicev1Project
  }
}

export interface Servicev1Application {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  app?: ApplicationsApplication
  clusterIdentifier?: string
  createdAt?: string
  lastModifiedAt?: string
  name?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  repoIdentifier?: string
  stale?: boolean
}

export interface Servicev1ApplicationDeleteRequestOptions {
  removeExistingFinalizers?: boolean
}

export interface Servicev1ApplicationPatchRequest {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  request?: ApplicationsApplicationPatchRequest
}

export interface Servicev1ApplicationQuery {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Filters for Application. Eg. "app.status.sync.status": "Synced" or "app.status.sync.status": { "$in": ["Synced", "NotSynced"]
   */
  filter?: { [key: string]: any }
  metadataOnly?: boolean
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  pageIndex?: number
  pageSize?: number
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  searchTerm?: string
  sortBy?: ApplicationQueryApplicationSortByOptions
  sortOrder?: V1SortOrderOptions
}

export interface Servicev1Applicationlist {
  content?: Servicev1Application[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface Servicev1Cluster {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  cluster?: ClustersCluster
  createdAt?: string
  identifier?: string
  lastModifiedAt?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  stale?: boolean
  tags?: {
    [key: string]: string
  }
}

export interface Servicev1ClusterQuery {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  /**
   * Filters for Clusters. Eg. "identifier": { "$in": ["id1", "id2"]
   */
  filter?: { [key: string]: any }
  identifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  pageIndex?: number
  pageSize?: number
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  searchTerm?: string
  sortBy?: ClusterQueryClusterSortByOptions
  sortOrder?: V1SortOrderOptions
}

export interface Servicev1Empty {
  [key: string]: any
}

export interface Servicev1GnuPGPublicKeyList {
  content?: V1Gnupg[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export type Servicev1HealthStatus = 'HEALTH_STATUS_UNSET' | 'HEALTHY' | 'UNHEALTHY'

export interface Servicev1Project {
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface Servicev1ReconcilerFilter {
  projectNames?: string[]
}

export interface Servicev1Repository {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  createdAt?: string
  identifier?: string
  lastModifiedAt?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  repository?: RepositoriesRepository
  repositoryCredentialsId?: string
  stale?: boolean
}

export interface Servicev1RepositoryCertificate {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  cert?: CertificatesRepositoryCertificate
  createdAt?: string
  lastModifiedAt?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface Servicev1RepositoryCredentials {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  createdAt?: string
  identifier?: string
  lastModifiedAt?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  repoCreds?: HrepocredsRepoCreds
  stale?: boolean
}

export interface Servicev1RepositoryCredentialsList {
  content?: Servicev1RepositoryCredentials[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

/**
 * Represents a Persistent Disk resource in AWS.
 *
 * An AWS EBS disk must exist before mounting to a container. The disk
 * must also be in the same AWS zone as the kubelet. An AWS EBS disk
 * can only be mounted as read/write once. AWS EBS volumes support
 * ownership management and SELinux relabeling.
 */
export interface V1AWSElasticBlockStoreVolumeSource {
  fsType?: string
  partition?: number
  readOnly?: boolean
  volumeID?: string
}

/**
 * Affinity is a group of affinity scheduling rules.
 */
export interface V1Affinity {
  nodeAffinity?: V1NodeAffinity
  podAffinity?: V1PodAffinity
  podAntiAffinity?: V1PodAntiAffinity
}

export interface V1Agent {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  createdAt?: V1Time
  credentials?: V1AgentCredentials
  description?: string
  disasterRecoveryNode?: V1DisasterRecoveryNode
  health?: V1AgentHealth
  identifier?: string
  /**
   * Indicates if the agent is for PLG.
   */
  isPLG?: boolean
  lastModifiedAt?: V1Time
  metadata?: V1AgentMetadata
  name?: string
  operator?: V1AgentOperator
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  scope?: V1AgentScope
  tags?: {
    [key: string]: string
  }
  type?: V1AgentType
  upgradeAvailable?: boolean
  version?: V1SemanticVersion
}

export interface V1AgentComponentHealth {
  k8sError?: string
  message?: string
  status?: Servicev1HealthStatus
  version?: string
}

export interface V1AgentCredentials {
  privateKey?: string
  publicKey?: string
}

export interface V1AgentHealth {
  argoAppController?: V1AgentComponentHealth
  argoAppSetController?: V1AgentComponentHealth
  argoRedisServer?: V1AgentComponentHealth
  argoRepoServer?: V1AgentComponentHealth
  connectionStatus?: V1ConnectedStatus
  harnessGitopsAgent?: V1AgentComponentHealth
  lastHeartbeat?: string
}

export interface V1AgentList {
  content?: V1Agent[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface V1AgentMetadata {
  deployedApplicationCount?: number
  existingInstallation?: boolean
  highAvailability?: boolean
  infraType?: V1ClusterInfraType
  isNamespaced?: boolean
  mappedProjects?: Servicev1AppProjectMapping
  namespace?: string
}

export type V1AgentOperator = 'UNKNOWN' | 'ARGO' | 'FLAMINGO'

export interface V1AgentQuery {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  drIdentifier?: string
  /**
   * Filters for Agents.
   */
  filter?: { [key: string]: any }
  identifier?: string
  ignoreScope?: boolean
  metadataOnly?: boolean
  name?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  pageIndex?: number
  pageSize?: number
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  scope?: V1AgentScope
  searchTerm?: string
  sortBy?: AgentQueryAgentSortByOptions
  sortOrder?: V1SortOrderOptions
  tags?: string[]
  type?: V1AgentType
}

export interface V1AgentScaleRequest {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  identifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  replicas?: number
  type?: string
}

export type V1AgentScope = 'AGENT_SCOPE_UNSET' | 'ACCOUNT' | 'ORG' | 'PROJECT'

export interface V1AgentSetPrimaryNodeRequest {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  /**
   * Disable sync windows for the new primary agent.
   */
  disableSyncWindows?: boolean
  /**
   * Disaster Recovery Identifier for entity.
   */
  disasterRecoveryIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export type V1AgentType =
  | 'AGENT_TYPE_UNSET'
  | 'CONNECTED_ARGO_PROVIDER'
  | 'MANAGED_ARGO_PROVIDER'
  | 'HOSTED_ARGO_PROVIDER'

export interface V1AnalysisRunArgument {
  name?: string
  value?: string
  valueFrom?: V1ArgumentValueFrom
}

export interface V1AnalysisRunMetadata {
  annotations?: {
    [key: string]: string
  }
  labels?: {
    [key: string]: string
  }
}

export interface V1AppProjectMappingCreateRequestV2 {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  argoProjectName?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface V1AppProjectMappingQueryV2 {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  argoProjectName?: string
  /**
   * app project mapping identifier.
   */
  identifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface V1AppProjectMappingV2 {
  ArgoProjectName?: string
  accountIdentifier?: string
  agentIdentifier?: string
  createdAt?: string
  identifier?: string
  lastModifiedAt?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface V1AppProjectMappingV2List {
  appProjectMappings?: V1AppProjectMappingV2[]
}

export interface V1ApplicationStatusCounts {
  healthStatusCounts?: V1HealthStatusCounts
  syncStatusCounts?: V1SyncStatusCounts
  total?: number
}

export interface V1ApplicationSyncStatus {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  applicationName?: string
  createdAt?: string
  lastKnownRevisionId?: string
  lastModifiedAt?: string
  operationState?: ApplicationsOperationState
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  reqIdentifier?: string
  syncedBy?: V1User
}

export interface V1ApplicationSyncStatusQuery {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  applicationName?: string
  endTime?: number
  operationPhase?: V1OperationPhase[]
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  pageIndex?: number
  pageSize?: number
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  searchTerm?: string
  startTime?: number
}

export interface V1ApplicationSyncStatuslist {
  content?: V1ApplicationSyncStatus[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface V1ArgumentValueFrom {
  fieldRef?: V1FieldRef
  podTemplateHashValue?: string
}

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 */
export interface V1AzureDiskVolumeSource {
  cachingMode?: string
  diskName?: string
  diskURI?: string
  fsType?: string
  kind?: string
  readOnly?: boolean
}

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 */
export interface V1AzureFileVolumeSource {
  readOnly?: boolean
  secretName?: string
  shareName?: string
}

export interface V1CSIVolumeSource {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   */
  driver?: string
  fsType?: string
  nodePublishSecretRef?: V1LocalObjectReference
  readOnly?: boolean
  volumeAttributes?: {
    [key: string]: string
  }
}

/**
 * CanaryStep defines a step of a canary deployment.
 */
export interface V1CanaryStep {
  analysis?: V1RolloutAnalysis
  experiment?: V1RolloutExperimentStep
  pause?: V1RolloutPause
  setCanaryScale?: V1SetCanaryScale
  setHeaderRoute?: V1SetHeaderRoute
  setMirrorRoute?: V1SetMirrorRoute
  setWeight?: number
}

/**
 * Adds and removes POSIX capabilities from running containers.
 */
export interface V1Capabilities {
  add?: string[]
  drop?: string[]
}

/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod
 * Cephfs volumes do not support ownership management or SELinux relabeling.
 */
export interface V1CephFSVolumeSource {
  monitors?: string[]
  path?: string
  readOnly?: boolean
  secretFile?: string
  secretRef?: V1LocalObjectReference
  user?: string
}

export interface V1Certificatelist {
  content?: Servicev1RepositoryCertificate[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

/**
 * Represents a cinder volume resource in Openstack.
 * A Cinder volume must exist before mounting to a container.
 * The volume must also be in the same region as the kubelet.
 * Cinder volumes support ownership management and SELinux relabeling.
 */
export interface V1CinderVolumeSource {
  fsType?: string
  readOnly?: boolean
  secretRef?: V1LocalObjectReference
  volumeID?: string
}

export interface V1CloudWatchMetric {
  interval?: string
  metricDataQueries?: V1CloudWatchMetricDataQuery[]
}

export interface V1CloudWatchMetricDataQuery {
  expression?: string
  id?: string
  label?: string
  metricStat?: V1CloudWatchMetricStat
  period?: IntstrIntOrString
  returnData?: boolean
}

export interface V1CloudWatchMetricStat {
  metric?: V1CloudWatchMetricStatMetric
  period?: IntstrIntOrString
  stat?: string
  unit?: string
}

export interface V1CloudWatchMetricStatMetric {
  dimensions?: V1CloudWatchMetricStatMetricDimension[]
  metricName?: string
  namespace?: string
}

export interface V1CloudWatchMetricStatMetricDimension {
  name?: string
  value?: string
}

export type V1ClusterInfraType = 'UNSET' | 'OPENSHIFT'

export interface V1Clusterlist {
  content?: Servicev1Cluster[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

/**
 * ConfigMapEnvSource selects a ConfigMap to populate the environment
 * variables with.
 *
 * The contents of the target ConfigMap's Data field will represent the
 * key-value pairs as environment variables.
 */
export interface V1ConfigMapEnvSource {
  localObjectReference?: V1LocalObjectReference
  optional?: boolean
}

export interface V1ConfigMapKeySelector {
  /**
   * The key to select.
   */
  key?: string
  localObjectReference?: V1LocalObjectReference
  optional?: boolean
}

/**
 * Adapts a ConfigMap into a projected volume.
 *
 * The contents of the target ConfigMap's Data field will be presented in a
 * projected volume as files using the keys in the Data field as the file names,
 * unless the items element is populated with specific mappings of keys to paths.
 * Note that this is identical to a configmap volume source without the default
 * mode.
 */
export interface V1ConfigMapProjection {
  items?: V1KeyToPath[]
  localObjectReference?: V1LocalObjectReference
  optional?: boolean
}

/**
 * Adapts a ConfigMap into a volume.
 *
 * The contents of the target ConfigMap's Data field will be presented in a
 * volume as files using the keys in the Data field as the file names, unless
 * the items element is populated with specific mappings of keys to paths.
 * ConfigMap volumes support ownership management and SELinux relabeling.
 */
export interface V1ConfigMapVolumeSource {
  defaultMode?: number
  items?: V1KeyToPath[]
  localObjectReference?: V1LocalObjectReference
  optional?: boolean
}

export type V1ConnectedStatus = 'CONNECTED_STATUS_UNSET' | 'CONNECTED' | 'DISCONNECTED'

/**
 * A single application container that you want to run within a pod.
 */
export interface V1Container {
  args?: string[]
  command?: string[]
  env?: V1EnvVar[]
  envFrom?: V1EnvFromSource[]
  image?: string
  imagePullPolicy?: string
  lifecycle?: V1Lifecycle
  livenessProbe?: V1Probe
  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   */
  name?: string
  ports?: V1ContainerPort[]
  readinessProbe?: V1Probe
  resources?: V1ResourceRequirements
  securityContext?: V1SecurityContext
  startupProbe?: V1Probe
  stdin?: boolean
  stdinOnce?: boolean
  terminationMessagePath?: string
  terminationMessagePolicy?: string
  tty?: boolean
  volumeDevices?: V1VolumeDevice[]
  volumeMounts?: V1VolumeMount[]
  workingDir?: string
}

/**
 * ContainerPort represents a network port in a single container.
 */
export interface V1ContainerPort {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   */
  containerPort?: number
  hostIP?: string
  hostPort?: number
  name?: string
  protocol?: string
}

export interface V1DashboardOverview {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  applicationCount?: number
  applicationStatusCounts?: V1ApplicationStatusCounts
  clusterCount?: number
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  repositoryCount?: number
}

export interface V1DatadogMetric {
  /**
   * ApiVersion refers to the Datadog API version being used (default: v1). v1 will eventually be deprecated.
   */
  apiVersion?: string
  interval?: string
  query?: string
}

export interface V1DeploymentsDetails {
  deploy?: number
  error?: number
  failed?: number
  failureRate?: number
  redeploy?: number
  rollback?: number
  running?: number
  startedAt?: string
  succeeded?: number
  terminating?: number
  totalDeployments?: number
}

export interface V1DisasterRecoveryNode {
  identifier?: string
  name?: string
  type?: V1DisasterRecoveryType
}

export type V1DisasterRecoveryType = 'UNKNOWN_TYPE' | 'PRIMARY' | 'SECONDARY'

export interface V1DownloadResponse {
  chunk?: string
}

/**
 * Represents downward API info for projecting into a projected volume.
 * Note that this is identical to a downwardAPI volume source without the default
 * mode.
 */
export interface V1DownwardAPIProjection {
  items?: V1DownwardAPIVolumeFile[]
}

export interface V1DownwardAPIVolumeFile {
  fieldRef?: V1ObjectFieldSelector
  mode?: number
  path?: string
  resourceFieldRef?: V1ResourceFieldSelector
}

/**
 * DownwardAPIVolumeSource represents a volume containing downward API info.
 * Downward API volumes support ownership management and SELinux relabeling.
 */
export interface V1DownwardAPIVolumeSource {
  defaultMode?: number
  items?: V1DownwardAPIVolumeFile[]
}

/**
 * DryRun defines the settings for running the analysis in Dry-Run mode.
 */
export interface V1DryRun {
  /**
   * Name of the metric which needs to be evaluated in the Dry-Run mode. Wildcard '*' is supported and denotes all
   * the available metrics.
   */
  metricName?: string
}

/**
 * Represents an empty directory for a pod.
 * Empty directory volumes support ownership management and SELinux relabeling.
 */
export interface V1EmptyDirVolumeSource {
  medium?: string
  sizeLimit?: ResourceQuantity
}

export interface V1EnvFromSource {
  configMapRef?: V1ConfigMapEnvSource
  prefix?: string
  secretRef?: V1SecretEnvSource
}

/**
 * EnvVar represents an environment variable present in a Container.
 */
export interface V1EnvVar {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   */
  name?: string
  value?: string
  valueFrom?: V1EnvVarSource
}

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 */
export interface V1EnvVarSource {
  configMapKeyRef?: V1ConfigMapKeySelector
  fieldRef?: V1ObjectFieldSelector
  resourceFieldRef?: V1ResourceFieldSelector
  secretKeyRef?: V1SecretKeySelector
}

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for
 * user-initiated activities such as debugging. Ephemeral containers have no resource or
 * scheduling guarantees, and they will not be restarted when they exit or when a Pod is
 * removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
 * Pod to exceed its resource allocation.
 *
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing
 * Pod. Ephemeral containers may not be removed or restarted.
 *
 * This is a beta feature available on clusters that haven't disabled the EphemeralContainers feature gate.
 */
export interface V1EphemeralContainer {
  ephemeralContainerCommon?: V1EphemeralContainerCommon
  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   * +optional
   */
  targetContainerName?: string
}

/**
 * EphemeralContainerCommon is a copy of all fields in Container to be inlined in
 * EphemeralContainer. This separate type allows easy conversion from EphemeralContainer
 * to Container and allows separate documentation for the fields of EphemeralContainer.
 * When a new field is added to Container it must be added here as well.
 */
export interface V1EphemeralContainerCommon {
  args?: string[]
  command?: string[]
  env?: V1EnvVar[]
  envFrom?: V1EnvFromSource[]
  image?: string
  imagePullPolicy?: string
  lifecycle?: V1Lifecycle
  livenessProbe?: V1Probe
  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   */
  name?: string
  ports?: V1ContainerPort[]
  readinessProbe?: V1Probe
  resources?: V1ResourceRequirements
  securityContext?: V1SecurityContext
  startupProbe?: V1Probe
  stdin?: boolean
  stdinOnce?: boolean
  terminationMessagePath?: string
  terminationMessagePolicy?: string
  tty?: boolean
  volumeDevices?: V1VolumeDevice[]
  volumeMounts?: V1VolumeMount[]
  workingDir?: string
}

/**
 * Represents an ephemeral volume that is handled by a normal storage driver.
 */
export interface V1EphemeralVolumeSource {
  volumeClaimTemplate?: V1PersistentVolumeClaimTemplate
}

/**
 * ExecAction describes a "run in container" action.
 */
export interface V1ExecAction {
  command?: string[]
}

/**
 * Represents a Fibre Channel volume.
 * Fibre Channel volumes can only be mounted as read/write once.
 * Fibre Channel volumes support ownership management and SELinux relabeling.
 */
export interface V1FCVolumeSource {
  fsType?: string
  lun?: number
  readOnly?: boolean
  targetWWNs?: string[]
  wwids?: string[]
}

export interface V1FieldRef {
  fieldPath?: string
}

/**
 * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
 *
 * Each key is either a '.' representing the field itself, and will always map to an empty set,
 * or a string representing a sub-field or item. The string will follow one of these four formats:
 * 'f:<name>', where <name> is the name of a field in a struct, or key in a map
 * 'v:<value>', where <value> is the exact json formatted value of a list item
 * 'i:<index>', where <index> is position of a item in a list
 * 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
 * If a key maps to an empty Fields value, the field that key represents is part of the set.
 *
 * The exact format is defined in sigs.k8s.io/structured-merge-diff
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1FieldsV1 {
  /**
   * Raw is the underlying serialization of this object.
   */
  Raw?: string
}

/**
 * FlexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 */
export interface V1FlexVolumeSource {
  /**
   * driver is the name of the driver to use for this volume.
   */
  driver?: string
  fsType?: string
  options?: {
    [key: string]: string
  }
  readOnly?: boolean
  secretRef?: V1LocalObjectReference
}

/**
 * Represents a Flocker volume mounted by the Flocker agent.
 * One and only one of datasetName and datasetUUID should be set.
 * Flocker volumes do not support ownership management or SELinux relabeling.
 */
export interface V1FlockerVolumeSource {
  datasetName?: string
  datasetUUID?: string
}

/**
 * Represents a Persistent Disk resource in Google Compute Engine.
 *
 * A GCE PD must exist before mounting to a container. The disk must
 * also be in the same GCE project and zone as the kubelet. A GCE PD
 * can only be mounted as read/write once or read-only many times. GCE
 * PDs support ownership management and SELinux relabeling.
 */
export interface V1GCEPersistentDiskVolumeSource {
  fsType?: string
  partition?: number
  pdName?: string
  readOnly?: boolean
}

export interface V1GRPCAction {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   */
  port?: number
  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   * +optional
   * +default=""
   */
  service?: string
}

/**
 * Represents a volume that is populated with the contents of a git repository.
 * Git repo volumes do not support ownership management.
 * Git repo volumes support SELinux relabeling.
 *
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 */
export interface V1GitRepoVolumeSource {
  directory?: string
  repository?: string
  revision?: string
}

/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod.
 * Glusterfs volumes do not support ownership management or SELinux relabeling.
 */
export interface V1GlusterfsVolumeSource {
  endpoints?: string
  path?: string
  readOnly?: boolean
}

export interface V1Gnupg {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  createdAt?: string
  gnuPGPublicKey?: GpgkeysGnuPGPublicKey
  lastModifiedAt?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface V1GraphiteMetric {
  address?: string
  query?: string
}

/**
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1GroupKind {
  group?: string
  kind?: string
}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 */
export interface V1HTTPGetAction {
  host?: string
  httpHeaders?: V1HTTPHeader[]
  path?: string
  port?: IntstrIntOrString
  scheme?: string
}

export interface V1HTTPHeader {
  name?: string
  value?: string
}

export interface V1HeaderRoutingMatch {
  headerName?: string
  headerValue?: V1StringMatch
}

export interface V1HealthStatusCounts {
  degraded?: number
  healthy?: number
  missing?: number
  progressing?: number
  suspended?: number
  unknown?: number
}

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 */
export interface V1HostAlias {
  /**
   * Hostnames for the above IP address.
   */
  hostnames?: string[]
  /**
   * IP address of the host file entry.
   */
  ip?: string
}

/**
 * Represents a host path mapped into a pod.
 * Host path volumes do not support ownership management or SELinux relabeling.
 */
export interface V1HostPathVolumeSource {
  path?: string
  type?: string
}

/**
 * Represents an ISCSI disk.
 * ISCSI volumes can only be mounted as read/write once.
 * ISCSI volumes support ownership management and SELinux relabeling.
 */
export interface V1ISCSIVolumeSource {
  chapAuthDiscovery?: boolean
  chapAuthSession?: boolean
  fsType?: string
  initiatorName?: string
  /**
   * iqn is the target iSCSI Qualified Name.
   */
  iqn?: string
  iscsiInterface?: string
  /**
   * lun represents iSCSI Target Lun number.
   */
  lun?: number
  portals?: string[]
  readOnly?: boolean
  secretRef?: V1LocalObjectReference
  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   */
  targetPortal?: string
}

export interface V1InfluxdbMetric {
  profile?: string
  query?: string
}

export interface V1JobMetric {
  metadata?: V1ObjectMeta
  spec?: V1JobSpec
}

/**
 * JobSpec describes how the job execution will look like.
 */
export interface V1JobSpec {
  activeDeadlineSeconds?: string
  backoffLimit?: number
  /**
   * CompletionMode specifies how Pod completions are tracked. It can be
   * `NonIndexed` (default) or `Indexed`.
   *
   * `NonIndexed` means that the Job is considered complete when there have
   * been .spec.completions successfully completed Pods. Each Pod completion is
   * homologous to each other.
   *
   * `Indexed` means that the Pods of a
   * Job get an associated completion index from 0 to (.spec.completions - 1),
   * available in the annotation batch.kubernetes.io/job-completion-index.
   * The Job is considered complete when there is one successfully completed Pod
   * for each index.
   * When value is `Indexed`, .spec.completions must be specified and
   * `.spec.parallelism` must be less than or equal to 10^5.
   * In addition, The Pod name takes the form
   * `$(job-name)-$(index)-$(random-string)`,
   * the Pod hostname takes the form `$(job-name)-$(index)`.
   *
   * More completion modes can be added in the future.
   * If the Job controller observes a mode that it doesn't recognize, which
   * is possible during upgrades due to version skew, the controller
   * skips updates for the Job.
   * +optional
   */
  completionMode?: string
  completions?: number
  manualSelector?: boolean
  parallelism?: number
  selector?: V1LabelSelector
  /**
   * Suspend specifies whether the Job controller should create Pods or not. If
   * a Job is created with suspend set to true, no Pods are created by the Job
   * controller. If a Job is suspended after creation (i.e. the flag goes from
   * false to true), the Job controller will delete all active Pods associated
   * with this Job. Users must design their workload to gracefully handle this.
   * Suspending a Job will reset the StartTime field of the Job, effectively
   * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
   *
   * +optional
   */
  suspend?: boolean
  template?: V1PodTemplateSpec
  ttlSecondsAfterFinished?: number
}

export interface V1KayentaMetric {
  address?: string
  application?: string
  canaryConfigName?: string
  configurationAccountName?: string
  metricsAccountName?: string
  scopes?: V1KayentaScope[]
  storageAccountName?: string
  threshold?: V1KayentaThreshold
}

export interface V1KayentaScope {
  controlScope?: V1ScopeDetail
  experimentScope?: V1ScopeDetail
  name?: string
}

export interface V1KayentaThreshold {
  marginal?: string
  pass?: string
}

/**
 * Maps a string key to a path within a volume.
 */
export interface V1KeyToPath {
  /**
   * key is the key to project.
   */
  key?: string
  mode?: number
  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   */
  path?: string
}

export interface V1LabelSelector {
  matchExpressions?: V1LabelSelectorRequirement[]
  matchLabels?: {
    [key: string]: string
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 */
export interface V1LabelSelectorRequirement {
  key?: string
  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   */
  operator?: string
  values?: string[]
}

/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle
 * events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
 * until the action is complete, unless the container process fails, in which case the handler is aborted.
 */
export interface V1Lifecycle {
  postStart?: V1LifecycleHandler
  preStop?: V1LifecycleHandler
}

/**
 * LifecycleHandler defines a specific action that should be taken in a lifecycle
 * hook. One and only one of the fields, except TCPSocket must be specified.
 */
export interface V1LifecycleHandler {
  exec?: V1ExecAction
  httpGet?: V1HTTPGetAction
  tcpSocket?: V1TCPSocketAction
}

/**
 * ListMeta describes metadata that synthetic resources must have, including lists and
 * various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
 */
export interface V1ListMeta {
  /**
   * continue may be set if the user set a limit on the number of items returned, and indicates that
   * the server has more data available. The value is opaque and may be used to issue another request
   * to the endpoint that served this list to retrieve the next set of available objects. Continuing a
   * consistent list may not be possible if the server configuration has changed or more than a few
   * minutes have passed. The resourceVersion field returned when using this continue value will be
   * identical to the value in the first response, unless you have received this token from an error
   * message.
   */
  continue?: string
  remainingItemCount?: string
  resourceVersion?: string
  selfLink?: string
}

/**
 * LoadBalancerIngress represents the status of a load-balancer ingress point:
 * traffic intended for the service should be sent to an ingress point.
 */
export interface V1LoadBalancerIngress {
  hostname?: string
  ip?: string
  ports?: V1PortStatus[]
}

export interface V1LocalObjectReference {
  name?: string
}

/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
 * that the fieldset applies to.
 */
export interface V1ManagedFieldsEntry {
  /**
   * APIVersion defines the version of this resource that this field set
   * applies to. The format is "group/version" just like the top-level
   * APIVersion field. It is necessary to track the version of a field
   * set because it cannot be automatically converted.
   */
  apiVersion?: string
  fieldsType?: string
  fieldsV1?: V1FieldsV1
  /**
   * Manager is an identifier of the workflow managing these fields.
   */
  manager?: string
  /**
   * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
   * The only valid values for this field are 'Apply' and 'Update'.
   */
  operation?: string
  /**
   * Subresource is the name of the subresource used to update that object, or
   * empty string if the object was updated through the main resource. The
   * value of this field is used to distinguish between managers, even if they
   * share the same name. For example, a status update will be distinct from a
   * regular update using the same manager name.
   * Note that the APIVersion field is not related to the Subresource field and
   * it always corresponds to the version of the main resource.
   */
  subresource?: string
  time?: V1Time
}

/**
 * MeasurementRetention defines the settings for retaining the number of measurements during the analysis.
 */
export interface V1MeasurementRetention {
  /**
   * Limit is the maximum number of measurements to be retained for this given metric.
   */
  limit?: number
  /**
   * MetricName is the name of the metric on which this retention policy should be applied.
   */
  metricName?: string
}

export interface V1Metric {
  consecutiveErrorLimit?: IntstrIntOrString
  count?: IntstrIntOrString
  failureCondition?: string
  failureLimit?: IntstrIntOrString
  inconclusiveLimit?: IntstrIntOrString
  initialDelay?: string
  interval?: string
  name?: string
  provider?: V1MetricProvider
  successCondition?: string
}

export interface V1MetricProvider {
  cloudWatch?: V1CloudWatchMetric
  datadog?: V1DatadogMetric
  graphite?: V1GraphiteMetric
  influxdb?: V1InfluxdbMetric
  job?: V1JobMetric
  kayenta?: V1KayentaMetric
  newRelic?: V1NewRelicMetric
  plugin?: {
    [key: string]: string
  }
  prometheus?: V1PrometheusMetric
  skywalking?: V1SkyWalkingMetric
  wavefront?: V1WavefrontMetric
  web?: V1WebMetric
}

/**
 * MicroTime is version of Time with microsecond level precision.
 *
 * +protobuf.options.marshal=false
 * +protobuf.as=Timestamp
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1MicroTime {
  /**
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive. This field may be limited in precision depending on context.
   */
  nanos?: number
  /**
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   */
  seconds?: string
}

/**
 * Represents an NFS mount that lasts the lifetime of a pod.
 * NFS volumes do not support ownership management or SELinux relabeling.
 */
export interface V1NFSVolumeSource {
  path?: string
  readOnly?: boolean
  server?: string
}

export interface V1NewRelicMetric {
  profile?: string
  query?: string
}

/**
 * Node affinity is a group of node affinity scheduling rules.
 */
export interface V1NodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: V1PreferredSchedulingTerm[]
  requiredDuringSchedulingIgnoredDuringExecution?: V1NodeSelector
}

export interface V1NodeSelector {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   */
  nodeSelectorTerms?: V1NodeSelectorTerm[]
}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 */
export interface V1NodeSelectorRequirement {
  /**
   * The label key that the selector applies to.
   */
  key?: string
  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   */
  operator?: string
  values?: string[]
}

export interface V1NodeSelectorTerm {
  matchExpressions?: V1NodeSelectorRequirement[]
  matchFields?: V1NodeSelectorRequirement[]
}

/**
 * NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
 */
export interface V1NodeSystemInfo {
  architecture?: string
  /**
   * Boot ID reported by the node.
   */
  bootID?: string
  /**
   * ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
   */
  containerRuntimeVersion?: string
  /**
   * Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
   */
  kernelVersion?: string
  /**
   * KubeProxy Version reported by the node.
   */
  kubeProxyVersion?: string
  /**
   * Kubelet Version reported by the node.
   */
  kubeletVersion?: string
  machineID?: string
  operatingSystem?: string
  /**
   * OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
   */
  osImage?: string
  systemUUID?: string
}

export interface V1OCIRepoType {
  /**
   * OCI Repository URL.
   */
  repoURL?: string
}

export interface V1OCIRepoTypeResponse {
  ociRepoType?: OCIRepoTypeResponseOCIRepoTypeEnum
}

export interface V1ObjectFieldSelector {
  apiVersion?: string
  /**
   * Path of the field to select in the specified API version.
   */
  fieldPath?: string
}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects
 * users must create.
 */
export interface V1ObjectMeta {
  annotations?: {
    [key: string]: string
  }
  /**
   * Deprecated: ClusterName is a legacy field that was always cleared by
   * the system and never used; it will be removed completely in 1.25.
   *
   * The name in the go struct is changed to help clients detect
   * accidental use.
   *
   * +optional
   */
  clusterName?: string
  creationTimestamp?: V1Time
  deletionGracePeriodSeconds?: string
  deletionTimestamp?: V1Time
  finalizers?: string[]
  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique
   * name ONLY IF the Name field has not been provided.
   * If this field is used, the name returned to the client will be different
   * than the name passed. This value will also be combined with a unique suffix.
   * The provided value has the same validation rules as the Name field,
   * and may be truncated by the length of the suffix required to make the value
   * unique on the server.
   *
   * If this field is specified and the generated name exists, the server will return a 409.
   *
   * Applied only if Name is not specified.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
   * +optional
   */
  generateName?: string
  generation?: string
  labels?: {
    [key: string]: string
  }
  /**
   * ManagedFields maps workflow-id and version to the set of fields
   * that are managed by that workflow. This is mostly for internal
   * housekeeping, and users typically shouldn't need to set or
   * understand this field. A workflow can be the user's name, a
   * controller's name, or the name of a specific apply path like
   * "ci-cd". The set of fields is always in the version that the
   * workflow used when modifying the object.
   *
   * +optional
   */
  managedFields?: V1ManagedFieldsEntry[]
  name?: string
  /**
   * Namespace defines the space within which each name must be unique. An empty namespace is
   * equivalent to the "default" namespace, but "default" is the canonical representation.
   * Not all objects are required to be scoped to a namespace - the value of this field for
   * those objects will be empty.
   *
   * Must be a DNS_LABEL.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/namespaces
   * +optional
   */
  namespace?: string
  ownerReferences?: V1OwnerReference[]
  /**
   * An opaque value that represents the internal version of this object that can
   * be used by clients to determine when objects have changed. May be used for optimistic
   * concurrency, change detection, and the watch operation on a resource or set of resources.
   * Clients must treat these values as opaque and passed unmodified back to the server.
   * They may only be valid for a particular resource or set of resources.
   *
   * Populated by the system.
   * Read-only.
   * Value must be treated as opaque by clients and .
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   * +optional
   */
  resourceVersion?: string
  selfLink?: string
  /**
   * UID is the unique in time and space value for this object. It is typically generated by
   * the server on successful creation of a resource and is not allowed to change on PUT
   * operations.
   *
   * Populated by the system.
   * Read-only.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   * +optional
   */
  uid?: string
}

export type V1OperationPhase = 'OPERATION_PHASE_UNSET' | 'RUNNING' | 'FAILED' | 'SUCCEEDED'

export interface V1OwnerReference {
  /**
   * API version of the referent.
   */
  apiVersion?: string
  blockOwnerDeletion?: boolean
  controller?: boolean
  kind?: string
  name?: string
  uid?: string
}

export interface V1PersistentVolumeClaimSpec {
  accessModes?: string[]
  dataSource?: V1TypedLocalObjectReference
  dataSourceRef?: V1TypedLocalObjectReference
  resources?: V1ResourceRequirements
  selector?: V1LabelSelector
  storageClassName?: string
  volumeMode?: string
  volumeName?: string
}

/**
 * PersistentVolumeClaimTemplate is used to produce
 * PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
 */
export interface V1PersistentVolumeClaimTemplate {
  metadata?: V1ObjectMeta
  spec?: V1PersistentVolumeClaimSpec
}

/**
 * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
 * This volume finds the bound PV and mounts that volume for the pod. A
 * PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
 * type of volume that is owned by someone else (the system).
 */
export interface V1PersistentVolumeClaimVolumeSource {
  claimName?: string
  readOnly?: boolean
}

/**
 * Represents a Photon Controller persistent disk resource.
 */
export interface V1PhotonPersistentDiskVolumeSource {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   */
  fsType?: string
  pdID?: string
}

/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 */
export interface V1PodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: V1WeightedPodAffinityTerm[]
  requiredDuringSchedulingIgnoredDuringExecution?: V1PodAffinityTerm[]
}

export interface V1PodAffinityTerm {
  labelSelector?: V1LabelSelector
  namespaceSelector?: V1LabelSelector
  namespaces?: string[]
  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   */
  topologyKey?: string
}

/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 */
export interface V1PodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution?: V1WeightedPodAffinityTerm[]
  requiredDuringSchedulingIgnoredDuringExecution?: V1PodAffinityTerm[]
}

/**
 * PodDNSConfig defines the DNS parameters of a pod in addition to
 * those generated from DNSPolicy.
 */
export interface V1PodDNSConfig {
  nameservers?: string[]
  options?: V1PodDNSConfigOption[]
  searches?: string[]
}

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 */
export interface V1PodDNSConfigOption {
  /**
   * Required.
   */
  name?: string
  value?: string
}

/**
 * PodOS defines the OS parameters of a pod.
 */
export interface V1PodOS {
  name?: string
}

export interface V1PodReadinessGate {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   */
  conditionType?: string
}

/**
 * PodSecurityContext holds pod-level security attributes and common container settings.
 * Some fields are also present in container.securityContext.  Field values of
 * container.securityContext take precedence over field values of PodSecurityContext.
 */
export interface V1PodSecurityContext {
  /**
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  fsGroup?: string
  fsGroupChangePolicy?: string
  runAsGroup?: string
  runAsNonRoot?: boolean
  runAsUser?: string
  seLinuxOptions?: V1SELinuxOptions
  seccompProfile?: V1SeccompProfile
  supplementalGroups?: string[]
  sysctls?: V1Sysctl[]
  windowsOptions?: V1WindowsSecurityContextOptions
}

/**
 * PodSpec is a description of a pod.
 */
export interface V1PodSpec {
  activeDeadlineSeconds?: string
  affinity?: V1Affinity
  automountServiceAccountToken?: boolean
  containers?: V1Container[]
  dnsConfig?: V1PodDNSConfig
  dnsPolicy?: string
  enableServiceLinks?: boolean
  ephemeralContainers?: V1EphemeralContainer[]
  hostAliases?: V1HostAlias[]
  hostIPC?: boolean
  hostNetwork?: boolean
  hostPID?: boolean
  hostname?: string
  imagePullSecrets?: V1LocalObjectReference[]
  initContainers?: V1Container[]
  nodeName?: string
  nodeSelector?: {
    [key: string]: string
  }
  os?: V1PodOS
  overhead?: {
    [key: string]: ResourceQuantity
  }
  preemptionPolicy?: string
  priority?: number
  priorityClassName?: string
  readinessGates?: V1PodReadinessGate[]
  restartPolicy?: string
  runtimeClassName?: string
  schedulerName?: string
  securityContext?: V1PodSecurityContext
  serviceAccount?: string
  serviceAccountName?: string
  setHostnameAsFQDN?: boolean
  shareProcessNamespace?: boolean
  subdomain?: string
  terminationGracePeriodSeconds?: string
  tolerations?: V1Toleration[]
  topologySpreadConstraints?: V1TopologySpreadConstraint[]
  volumes?: V1Volume[]
}

export interface V1PodTemplateMetadata {
  annotations?: {
    [key: string]: string
  }
  labels?: {
    [key: string]: string
  }
}

export interface V1PodTemplateSpec {
  metadata?: V1ObjectMeta
  spec?: V1PodSpec
}

export interface V1PortStatus {
  error?: string
  port?: number
  protocol?: string
}

/**
 * PortworxVolumeSource represents a Portworx volume resource.
 */
export interface V1PortworxVolumeSource {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   */
  fsType?: string
  readOnly?: boolean
  volumeID?: string
}

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 */
export interface V1PreferredSchedulingTerm {
  preference?: V1NodeSelectorTerm
  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   */
  weight?: number
}

/**
 * Probe describes a health check to be performed against a container to determine whether it is
 * alive or ready to receive traffic.
 */
export interface V1Probe {
  failureThreshold?: number
  handler?: V1ProbeHandler
  initialDelaySeconds?: number
  periodSeconds?: number
  successThreshold?: number
  terminationGracePeriodSeconds?: string
  timeoutSeconds?: number
}

/**
 * ProbeHandler defines a specific action that should be taken in a probe.
 * One and only one of the fields must be specified.
 */
export interface V1ProbeHandler {
  exec?: V1ExecAction
  grpc?: V1GRPCAction
  httpGet?: V1HTTPGetAction
  tcpSocket?: V1TCPSocketAction
}

export interface V1ProjectedVolumeSource {
  defaultMode?: number
  sources?: V1VolumeProjection[]
}

export interface V1PrometheusAuth {
  sigv4?: V1Sigv4Config
}

export interface V1PrometheusMetric {
  address?: string
  authentication?: V1PrometheusAuth
  headers?: V1WebMetricHeader[]
  insecure?: boolean
  query?: string
  timeout?: string
}

/**
 * Represents a Quobyte mount that lasts the lifetime of a pod.
 * Quobyte volumes do not support ownership management or SELinux relabeling.
 */
export interface V1QuobyteVolumeSource {
  group?: string
  readOnly?: boolean
  registry?: string
  tenant?: string
  user?: string
  /**
   * volume is a string that references an already created Quobyte volume by name.
   */
  volume?: string
}

/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod.
 * RBD volumes support ownership management and SELinux relabeling.
 */
export interface V1RBDVolumeSource {
  fsType?: string
  image?: string
  keyring?: string
  monitors?: string[]
  pool?: string
  readOnly?: boolean
  secretRef?: V1LocalObjectReference
  user?: string
}

/**
 * RecentDeploymentQuery
 */
export interface V1RecentDeploymentQuery {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier: string
  applicationName?: string
  endTime?: number
  operationPhase?: V1OperationPhase[]
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  searchTerm?: string
  startTime?: number
}

export interface V1RecentDeploymentsDetailsList {
  content?: V1DeploymentsDetails[]
  empty?: boolean
  pageItemCount?: number
}

export interface V1RecentlyCreatedCount {
  recentlyCreated?: number
  total?: number
}

export interface V1RecentlyCreatedOverview {
  appCounts?: V1RecentlyCreatedCount
  clusterCounts?: V1RecentlyCreatedCount
  repoCounts?: V1RecentlyCreatedCount
}

export interface V1RepoListReq {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  /**
   * Filters for Repositories. Eg. "identifier": { "$in": ["id1", "id2"]
   */
  filter?: { [key: string]: any }
  inheritedCreds?: boolean
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  pageIndex?: number
  pageSize?: number
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  searchTerm?: string
  sortBy?: RepoListReqRepoSortByOptions
  sortOrder?: V1SortOrderOptions
}

export interface V1RepositoryCredentialsQuery {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  /**
   * Filters for Repo Credentials. Eg. "identifier": { "$in": ["id1", "id2"]
   */
  filter?: { [key: string]: any }
  identifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  pageIndex?: number
  pageSize?: number
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  searchTerm?: string
}

export interface V1Repositorylist {
  content?: Servicev1Repository[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface V1ResourceFieldSelector {
  containerName?: string
  divisor?: ResourceQuantity
  resource?: string
}

/**
 * ResourceRequirements describes the compute resource requirements.
 */
export interface V1ResourceRequirements {
  limits?: {
    [key: string]: ResourceQuantity
  }
  requests?: {
    [key: string]: ResourceQuantity
  }
}

export interface V1RolloutAnalysis {
  analysisRunMetadata?: V1AnalysisRunMetadata
  args?: V1AnalysisRunArgument[]
  dryRun?: V1DryRun[]
  measurementRetention?: V1MeasurementRetention[]
  templates?: V1RolloutAnalysisTemplate[]
}

export interface V1RolloutAnalysisRunInfo {
  error?: number
  failed?: number
  icon?: string
  inconclusive?: number
  jobs?: V1RolloutJobInfo[]
  metadata?: V1ObjectMeta
  metrics?: V1Metric[]
  nonJobInfo?: V1RolloutNonJobInfo[]
  revision?: string
  status?: string
  successful?: number
}

export interface V1RolloutAnalysisTemplate {
  clusterScope?: boolean
  templateName?: string
}

export interface V1RolloutContainerInfo {
  image?: string
  name?: string
}

export interface V1RolloutExperimentInfo {
  analysisRuns?: V1RolloutAnalysisRunInfo[]
  icon?: string
  message?: string
  metadata?: V1ObjectMeta
  replicaSets?: V1RolloutReplicaSetInfo[]
  revision?: string
  status?: string
}

export interface V1RolloutExperimentStep {
  analyses?: V1RolloutExperimentStepAnalysisTemplateRef[]
  duration?: string
  templates?: V1RolloutExperimentTemplate[]
}

export interface V1RolloutExperimentStepAnalysisTemplateRef {
  args?: V1AnalysisRunArgument[]
  clusterScope?: boolean
  name?: string
  requiredForCompletion?: boolean
  templateName?: string
}

export interface V1RolloutExperimentTemplate {
  metadata?: V1PodTemplateMetadata
  name?: string
  replicas?: number
  selector?: V1LabelSelector
  service?: V1TemplateService
  specRef?: string
  weight?: number
}

export interface V1RolloutInfo {
  actualWeight?: string
  analysisRuns?: V1RolloutAnalysisRunInfo[]
  available?: number
  canaryImages?: string[]
  canaryRevision?: number
  containers?: V1RolloutContainerInfo[]
  current?: number
  desired?: number
  experiments?: V1RolloutExperimentInfo[]
  generation?: string
  icon?: string
  message?: string
  metadata?: V1ObjectMeta
  previewImages?: string[]
  ready?: number
  replicaSets?: V1RolloutReplicaSetInfo[]
  restartedAt?: string
  setWeight?: string
  stableImages?: string[]
  status?: string
  step?: string
  steps?: V1CanaryStep[]
  strategy?: string
  updated?: number
}

export interface V1RolloutJobInfo {
  icon?: string
  metadata?: V1ObjectMeta
  metricName?: string
  startedAt?: V1Time
  status?: string
}

export interface V1RolloutNonJobInfo {
  metricName?: string
  startedAt?: V1Time
  status?: string
  value?: string
}

export interface V1RolloutPause {
  duration?: IntstrIntOrString
}

export interface V1RolloutPodInfo {
  icon?: string
  metadata?: V1ObjectMeta
  ready?: string
  restarts?: number
  status?: string
}

export interface V1RolloutReplicaSetInfo {
  active?: boolean
  available?: number
  canary?: boolean
  icon?: string
  images?: string[]
  metadata?: V1ObjectMeta
  ping?: boolean
  pods?: V1RolloutPodInfo[]
  pong?: boolean
  preview?: boolean
  replicas?: number
  revision?: string
  scaleDownDeadline?: string
  stable?: boolean
  status?: string
  template?: string
}

export interface V1RouteMatch {
  headers?: {
    [key: string]: V1StringMatch
  }
  method?: V1StringMatch
  path?: V1StringMatch
}

export interface V1SELinuxOptions {
  level?: string
  role?: string
  type?: string
  user?: string
}

export interface V1ScaleIOVolumeSource {
  fsType?: string
  /**
   * gateway is the host address of the ScaleIO API Gateway.
   */
  gateway?: string
  protectionDomain?: string
  readOnly?: boolean
  secretRef?: V1LocalObjectReference
  sslEnabled?: boolean
  storageMode?: string
  storagePool?: string
  /**
   * system is the name of the storage system as configured in ScaleIO.
   */
  system?: string
  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   */
  volumeName?: string
}

export interface V1ScopeDetail {
  end?: string
  region?: string
  scope?: string
  start?: string
  step?: string
}

export interface V1SeccompProfile {
  localhostProfile?: string
  /**
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   * +unionDiscriminator
   */
  type?: string
}

/**
 * SecretEnvSource selects a Secret to populate the environment
 * variables with.
 *
 * The contents of the target Secret's Data field will represent the
 * key-value pairs as environment variables.
 */
export interface V1SecretEnvSource {
  localObjectReference?: V1LocalObjectReference
  optional?: boolean
}

export interface V1SecretKeySelector {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key?: string
  localObjectReference?: V1LocalObjectReference
  optional?: boolean
}

/**
 * Adapts a secret into a projected volume.
 *
 * The contents of the target Secret's Data field will be presented in a
 * projected volume as files using the keys in the Data field as the file names.
 * Note that this is identical to a secret volume source without the default
 * mode.
 */
export interface V1SecretProjection {
  items?: V1KeyToPath[]
  localObjectReference?: V1LocalObjectReference
  optional?: boolean
}

/**
 * Adapts a Secret into a volume.
 *
 * The contents of the target Secret's Data field will be presented in a volume
 * as files using the keys in the Data field as the file names.
 * Secret volumes support ownership management and SELinux relabeling.
 */
export interface V1SecretVolumeSource {
  defaultMode?: number
  items?: V1KeyToPath[]
  optional?: boolean
  secretName?: string
}

/**
 * SecurityContext holds security configuration that will be applied to a container.
 * Some fields are present in both SecurityContext and PodSecurityContext.  When both
 * are set, the values in SecurityContext take precedence.
 */
export interface V1SecurityContext {
  allowPrivilegeEscalation?: boolean
  capabilities?: V1Capabilities
  privileged?: boolean
  procMount?: string
  readOnlyRootFilesystem?: boolean
  runAsGroup?: string
  runAsNonRoot?: boolean
  runAsUser?: string
  seLinuxOptions?: V1SELinuxOptions
  seccompProfile?: V1SeccompProfile
  windowsOptions?: V1WindowsSecurityContextOptions
}

export interface V1SemanticVersion {
  major?: string
  minor?: string
  patch?: string
}

/**
 * ServiceAccountTokenProjection represents a projected service account token
 * volume. This projection can be used to insert a service account token into
 * the pods runtime filesystem for use against APIs (Kubernetes API Server or
 * otherwise).
 */
export interface V1ServiceAccountTokenProjection {
  audience?: string
  expirationSeconds?: string
  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   */
  path?: string
}

export interface V1SetCanaryScale {
  matchTrafficWeight?: boolean
  replicas?: number
  weight?: number
}

export interface V1SetHeaderRoute {
  match?: V1HeaderRoutingMatch[]
  name?: string
}

export interface V1SetMirrorRoute {
  match?: V1RouteMatch[]
  name?: string
  percentage?: number
}

export interface V1Sigv4Config {
  address?: string
  profile?: string
  roleArn?: string
}

export interface V1SkyWalkingMetric {
  address?: string
  interval?: string
  query?: string
}

export type V1SortOrderOptions = 'SORT_ORDER_NOT_SET' | 'ASC' | 'DESC'

/**
 * Represents a StorageOS persistent volume resource.
 */
export interface V1StorageOSVolumeSource {
  fsType?: string
  readOnly?: boolean
  secretRef?: V1LocalObjectReference
  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   */
  volumeName?: string
  volumeNamespace?: string
}

export interface V1StringMatch {
  exact?: string
  prefix?: string
  regex?: string
}

export interface V1SyncStatusCounts {
  outOfSync?: number
  synced?: number
  unknown?: number
}

export interface V1Sysctl {
  name?: string
  value?: string
}

export interface V1TCPSocketAction {
  host?: string
  port?: IntstrIntOrString
}

export interface V1TemplateService {
  name?: string
}

/**
 * Time is a wrapper around time.Time which supports correct
 * marshaling to YAML and JSON.  Wrappers are provided for many
 * of the factory methods that the time package offers.
 *
 * +protobuf.options.marshal=false
 * +protobuf.as=Timestamp
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1Time {
  /**
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive. This field may be limited in precision depending on context.
   */
  nanos?: number
  /**
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   */
  seconds?: string
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 */
export interface V1Toleration {
  effect?: string
  key?: string
  operator?: string
  tolerationSeconds?: string
  value?: string
}

export interface V1TopApplicationPhaseStats {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  applicationName?: string
  deploymentRate?: number
  failed?: number
  succeeded?: number
  totalDeployments?: number
}

export interface V1TopApplicationPhaseStatsList {
  content?: V1TopApplicationPhaseStats[]
  empty?: boolean
}

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 */
export interface V1TopologySpreadConstraint {
  labelSelector?: V1LabelSelector
  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * |  P P  |  P P  |   P   |
   * +-------+-------+-------+
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   */
  maxSkew?: number
  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * |  P P  |  P P  |  P P  |
   * +-------+-------+-------+
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * This is an alpha field and requires enabling MinDomainsInPodTopologySpread feature gate.
   * +optional
   */
  minDomains?: number
  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes match the node selector.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   */
  topologyKey?: string
  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   *   but giving higher precedence to topologies that would help reduce the
   *   skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * | P P P |   P   |   P   |
   * +-------+-------+-------+
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   */
  whenUnsatisfiable?: string
}

export interface V1TypedLocalObjectReference {
  apiGroup?: string
  kind?: string
  name?: string
}

export interface V1UniqueMessage {
  unique?: boolean
}

export interface V1User {
  email?: string
  id?: string
  name?: string
}

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 */
export interface V1Volume {
  name?: string
  volumeSource?: V1VolumeSource
}

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 */
export interface V1VolumeDevice {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   */
  devicePath?: string
  name?: string
}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 */
export interface V1VolumeMount {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   */
  mountPath?: string
  mountPropagation?: string
  /**
   * This must match the Name of a Volume.
   */
  name?: string
  readOnly?: boolean
  subPath?: string
  subPathExpr?: string
}

export interface V1VolumeProjection {
  configMap?: V1ConfigMapProjection
  downwardAPI?: V1DownwardAPIProjection
  secret?: V1SecretProjection
  serviceAccountToken?: V1ServiceAccountTokenProjection
}

/**
 * Represents the source of a volume to mount.
 * Only one of its members may be specified.
 */
export interface V1VolumeSource {
  awsElasticBlockStore?: V1AWSElasticBlockStoreVolumeSource
  azureDisk?: V1AzureDiskVolumeSource
  azureFile?: V1AzureFileVolumeSource
  cephfs?: V1CephFSVolumeSource
  cinder?: V1CinderVolumeSource
  configMap?: V1ConfigMapVolumeSource
  csi?: V1CSIVolumeSource
  downwardAPI?: V1DownwardAPIVolumeSource
  emptyDir?: V1EmptyDirVolumeSource
  ephemeral?: V1EphemeralVolumeSource
  fc?: V1FCVolumeSource
  flexVolume?: V1FlexVolumeSource
  flocker?: V1FlockerVolumeSource
  gcePersistentDisk?: V1GCEPersistentDiskVolumeSource
  gitRepo?: V1GitRepoVolumeSource
  glusterfs?: V1GlusterfsVolumeSource
  hostPath?: V1HostPathVolumeSource
  iscsi?: V1ISCSIVolumeSource
  nfs?: V1NFSVolumeSource
  persistentVolumeClaim?: V1PersistentVolumeClaimVolumeSource
  photonPersistentDisk?: V1PhotonPersistentDiskVolumeSource
  portworxVolume?: V1PortworxVolumeSource
  projected?: V1ProjectedVolumeSource
  quobyte?: V1QuobyteVolumeSource
  rbd?: V1RBDVolumeSource
  scaleIO?: V1ScaleIOVolumeSource
  secret?: V1SecretVolumeSource
  storageos?: V1StorageOSVolumeSource
  vsphereVolume?: V1VsphereVirtualDiskVolumeSource
}

/**
 * Represents a vSphere volume resource.
 */
export interface V1VsphereVirtualDiskVolumeSource {
  fsType?: string
  storagePolicyID?: string
  storagePolicyName?: string
  volumePath?: string
}

export interface V1WavefrontMetric {
  address?: string
  query?: string
}

export interface V1WebMetric {
  body?: string
  headers?: V1WebMetricHeader[]
  insecure?: boolean
  jsonBody?: string
  jsonPath?: string
  method?: string
  timeoutSeconds?: string
  url?: string
}

export interface V1WebMetricHeader {
  key?: string
  value?: string
}

export interface V1WeightedPodAffinityTerm {
  podAffinityTerm?: V1PodAffinityTerm
  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   */
  weight?: number
}

/**
 * WindowsSecurityContextOptions contain Windows-specific options and credentials.
 */
export interface V1WindowsSecurityContextOptions {
  gmsaCredentialSpec?: string
  gmsaCredentialSpecName?: string
  hostProcess?: boolean
  runAsUserName?: string
}

export type Servicev1ReconcilerFilterRequestBody = Servicev1ReconcilerFilter

export type V1AgentRequestBody = V1Agent

export interface AgentServiceForServerListQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  identifier?: string
  name?: string
  type?: 'AGENT_TYPE_UNSET' | 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER' | 'HOSTED_ARGO_PROVIDER'
  tags?: string[]
  searchTerm?: string
  pageSize?: number
  pageIndex?: number
  scope?: 'AGENT_SCOPE_UNSET' | 'ACCOUNT' | 'ORG' | 'PROJECT'
  drIdentifier?: string
  sortBy?: 'SORT_BY_NOT_SET' | 'NAME' | 'HEALTH_STATUS' | 'CONNECTIVITY_STATUS'
  sortOrder?: 'SORT_ORDER_NOT_SET' | 'ASC' | 'DESC'
  metadataOnly?: boolean
  ignoreScope?: boolean
}

export type AgentServiceForServerListProps = Omit<
  GetProps<V1AgentList, GatewayruntimeError, AgentServiceForServerListQueryParams, void>,
  'path'
>

/**
 * List agents.
 */
export const AgentServiceForServerList = (props: AgentServiceForServerListProps) => (
  <Get<V1AgentList, GatewayruntimeError, AgentServiceForServerListQueryParams, void>
    path={`/api/v1/agents`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerListProps = Omit<
  UseGetProps<V1AgentList, GatewayruntimeError, AgentServiceForServerListQueryParams, void>,
  'path'
>

/**
 * List agents.
 */
export const useAgentServiceForServerList = (props: UseAgentServiceForServerListProps) =>
  useGet<V1AgentList, GatewayruntimeError, AgentServiceForServerListQueryParams, void>(`/api/v1/agents`, {
    base: window.getApiBaseUrl('gitops'),
    ...props
  })

export type AgentServiceForServerCreateProps = Omit<
  MutateProps<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create agent.
 */
export const AgentServiceForServerCreate = (props: AgentServiceForServerCreateProps) => (
  <Mutate<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, void>
    verb="POST"
    path={`/api/v1/agents`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerCreateProps = Omit<
  UseMutateProps<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create agent.
 */
export const useAgentServiceForServerCreate = (props: UseAgentServiceForServerCreateProps) =>
  useMutate<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, void>('POST', `/api/v1/agents`, {
    base: window.getApiBaseUrl('gitops'),
    ...props
  })

export type AgentServiceForServerSearchProps = Omit<
  MutateProps<V1AgentList, GatewayruntimeError, void, V1AgentQuery, void>,
  'path' | 'verb'
>

/**
 * Search agents.
 */
export const AgentServiceForServerSearch = (props: AgentServiceForServerSearchProps) => (
  <Mutate<V1AgentList, GatewayruntimeError, void, V1AgentQuery, void>
    verb="POST"
    path={`/api/v1/agents/search`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerSearchProps = Omit<
  UseMutateProps<V1AgentList, GatewayruntimeError, void, V1AgentQuery, void>,
  'path' | 'verb'
>

/**
 * Search agents.
 */
export const useAgentServiceForServerSearch = (props: UseAgentServiceForServerSearchProps) =>
  useMutate<V1AgentList, GatewayruntimeError, void, V1AgentQuery, void>('POST', `/api/v1/agents/search`, {
    base: window.getApiBaseUrl('gitops'),
    ...props
  })

export interface AgentServiceForServerUpdatePathParams {
  /**
   * The gitops-server generated ID for this gitops-agent
   */
  agentIdentifier: string
}

export type AgentServiceForServerUpdateProps = Omit<
  MutateProps<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, AgentServiceForServerUpdatePathParams>,
  'path' | 'verb'
> &
  AgentServiceForServerUpdatePathParams

/**
 * Update agents.
 */
export const AgentServiceForServerUpdate = ({ agentIdentifier, ...props }: AgentServiceForServerUpdateProps) => (
  <Mutate<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, AgentServiceForServerUpdatePathParams>
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerUpdateProps = Omit<
  UseMutateProps<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, AgentServiceForServerUpdatePathParams>,
  'path' | 'verb'
> &
  AgentServiceForServerUpdatePathParams

/**
 * Update agents.
 */
export const useAgentServiceForServerUpdate = ({ agentIdentifier, ...props }: UseAgentServiceForServerUpdateProps) =>
  useMutate<V1Agent, GatewayruntimeError, void, V1AgentRequestBody, AgentServiceForServerUpdatePathParams>(
    'PUT',
    (paramsInPath: AgentServiceForServerUpdatePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentApplicationServiceListQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * the application's name.
   */
  'query.name'?: string
  /**
   * forces application reconciliation if set to true.
   */
  'query.refresh'?: string
  /**
   * the project names to restrict returned list applications.
   */
  'query.project'?: string[]
  /**
   * when specified with a watch call, shows changes that occur after that particular version of a resource.
   */
  'query.resourceVersion'?: string
  /**
   * the selector to to restrict returned list to applications only with matched labels.
   */
  'query.selector'?: string
  /**
   * the repoURL to restrict returned list applications.
   */
  'query.repo'?: string
}

export interface AgentApplicationServiceListPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentApplicationServiceListProps = Omit<
  GetProps<
    ApplicationsApplicationList,
    GatewayruntimeError,
    AgentApplicationServiceListQueryParams,
    AgentApplicationServiceListPathParams
  >,
  'path'
> &
  AgentApplicationServiceListPathParams

/**
 * List returns list of applications for a specific agent
 *
 * List returns list of applications for a specific agent.
 */
export const AgentApplicationServiceList = ({ agentIdentifier, ...props }: AgentApplicationServiceListProps) => (
  <Get<
    ApplicationsApplicationList,
    GatewayruntimeError,
    AgentApplicationServiceListQueryParams,
    AgentApplicationServiceListPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceListProps = Omit<
  UseGetProps<
    ApplicationsApplicationList,
    GatewayruntimeError,
    AgentApplicationServiceListQueryParams,
    AgentApplicationServiceListPathParams
  >,
  'path'
> &
  AgentApplicationServiceListPathParams

/**
 * List returns list of applications for a specific agent
 *
 * List returns list of applications for a specific agent.
 */
export const useAgentApplicationServiceList = ({ agentIdentifier, ...props }: UseAgentApplicationServiceListProps) =>
  useGet<
    ApplicationsApplicationList,
    GatewayruntimeError,
    AgentApplicationServiceListQueryParams,
    AgentApplicationServiceListPathParams
  >(
    (paramsInPath: AgentApplicationServiceListPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentApplicationServiceCreateQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  clusterIdentifier?: string
  repoIdentifier?: string
}

export interface AgentApplicationServiceCreatePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentApplicationServiceCreateProps = Omit<
  MutateProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceCreateQueryParams,
    ApplicationsApplicationCreateRequest,
    AgentApplicationServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceCreatePathParams

/**
 * Create creates an application
 *
 * Creates application in project.
 */
export const AgentApplicationServiceCreate = ({ agentIdentifier, ...props }: AgentApplicationServiceCreateProps) => (
  <Mutate<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceCreateQueryParams,
    ApplicationsApplicationCreateRequest,
    AgentApplicationServiceCreatePathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/applications`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceCreateProps = Omit<
  UseMutateProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceCreateQueryParams,
    ApplicationsApplicationCreateRequest,
    AgentApplicationServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceCreatePathParams

/**
 * Create creates an application
 *
 * Creates application in project.
 */
export const useAgentApplicationServiceCreate = ({
  agentIdentifier,
  ...props
}: UseAgentApplicationServiceCreateProps) =>
  useMutate<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceCreateQueryParams,
    ApplicationsApplicationCreateRequest,
    AgentApplicationServiceCreatePathParams
  >(
    'POST',
    (paramsInPath: AgentApplicationServiceCreatePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentApplicationServiceManagedResourcesQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.namespace'?: string
  'query.name'?: string
  'query.version'?: string
  'query.group'?: string
  'query.kind'?: string
}

export interface AgentApplicationServiceManagedResourcesPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  queryApplicationName: string
}

export type AgentApplicationServiceManagedResourcesProps = Omit<
  GetProps<
    ApplicationsManagedResourcesResponse,
    GatewayruntimeError,
    AgentApplicationServiceManagedResourcesQueryParams,
    AgentApplicationServiceManagedResourcesPathParams
  >,
  'path'
> &
  AgentApplicationServiceManagedResourcesPathParams

/**
 * ManagedResources returns list of managed resources
 *
 * ManagedResources returns list of managed resources.
 */
export const AgentApplicationServiceManagedResources = ({
  agentIdentifier,
  queryApplicationName,
  ...props
}: AgentApplicationServiceManagedResourcesProps) => (
  <Get<
    ApplicationsManagedResourcesResponse,
    GatewayruntimeError,
    AgentApplicationServiceManagedResourcesQueryParams,
    AgentApplicationServiceManagedResourcesPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryApplicationName}/managed-resources`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceManagedResourcesProps = Omit<
  UseGetProps<
    ApplicationsManagedResourcesResponse,
    GatewayruntimeError,
    AgentApplicationServiceManagedResourcesQueryParams,
    AgentApplicationServiceManagedResourcesPathParams
  >,
  'path'
> &
  AgentApplicationServiceManagedResourcesPathParams

/**
 * ManagedResources returns list of managed resources
 *
 * ManagedResources returns list of managed resources.
 */
export const useAgentApplicationServiceManagedResources = ({
  agentIdentifier,
  queryApplicationName,
  ...props
}: UseAgentApplicationServiceManagedResourcesProps) =>
  useGet<
    ApplicationsManagedResourcesResponse,
    GatewayruntimeError,
    AgentApplicationServiceManagedResourcesQueryParams,
    AgentApplicationServiceManagedResourcesPathParams
  >(
    (paramsInPath: AgentApplicationServiceManagedResourcesPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryApplicationName}/managed-resources`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryApplicationName }, ...props }
  )

export interface AgentApplicationServiceGetQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * forces application reconciliation if set to true.
   */
  'query.refresh'?: string
  /**
   * the project names to restrict returned list applications.
   */
  'query.project'?: string[]
  /**
   * when specified with a watch call, shows changes that occur after that particular version of a resource.
   */
  'query.resourceVersion'?: string
  /**
   * the selector to to restrict returned list to applications only with matched labels.
   */
  'query.selector'?: string
  /**
   * the repoURL to restrict returned list applications.
   */
  'query.repo'?: string
}

export interface AgentApplicationServiceGetPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  /**
   * the application's name
   */
  queryName: string
}

export type AgentApplicationServiceGetProps = Omit<
  GetProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceGetQueryParams,
    AgentApplicationServiceGetPathParams
  >,
  'path'
> &
  AgentApplicationServiceGetPathParams

/**
 * Get returns an application by name
 *
 *  Get returns an application by name
 */
export const AgentApplicationServiceGet = ({
  agentIdentifier,
  queryName,
  ...props
}: AgentApplicationServiceGetProps) => (
  <Get<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceGetQueryParams,
    AgentApplicationServiceGetPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryName}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceGetProps = Omit<
  UseGetProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceGetQueryParams,
    AgentApplicationServiceGetPathParams
  >,
  'path'
> &
  AgentApplicationServiceGetPathParams

/**
 * Get returns an application by name
 *
 *  Get returns an application by name
 */
export const useAgentApplicationServiceGet = ({
  agentIdentifier,
  queryName,
  ...props
}: UseAgentApplicationServiceGetProps) =>
  useGet<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceGetQueryParams,
    AgentApplicationServiceGetPathParams
  >(
    (paramsInPath: AgentApplicationServiceGetPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryName}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryName }, ...props }
  )

export interface AgentApplicationServiceListResourceEventsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.resourceNamespace'?: string
  'query.resourceName'?: string
  'query.resourceUID'?: string
}

export interface AgentApplicationServiceListResourceEventsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  queryName: string
}

export type AgentApplicationServiceListResourceEventsProps = Omit<
  GetProps<
    ApplicationsEventList,
    GatewayruntimeError,
    AgentApplicationServiceListResourceEventsQueryParams,
    AgentApplicationServiceListResourceEventsPathParams
  >,
  'path'
> &
  AgentApplicationServiceListResourceEventsPathParams

/**
 * ListResourceEvents returns a list of event resources
 *
 * ListResourceEvents returns list of event resources.
 */
export const AgentApplicationServiceListResourceEvents = ({
  agentIdentifier,
  queryName,
  ...props
}: AgentApplicationServiceListResourceEventsProps) => (
  <Get<
    ApplicationsEventList,
    GatewayruntimeError,
    AgentApplicationServiceListResourceEventsQueryParams,
    AgentApplicationServiceListResourceEventsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryName}/events`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceListResourceEventsProps = Omit<
  UseGetProps<
    ApplicationsEventList,
    GatewayruntimeError,
    AgentApplicationServiceListResourceEventsQueryParams,
    AgentApplicationServiceListResourceEventsPathParams
  >,
  'path'
> &
  AgentApplicationServiceListResourceEventsPathParams

/**
 * ListResourceEvents returns a list of event resources
 *
 * ListResourceEvents returns list of event resources.
 */
export const useAgentApplicationServiceListResourceEvents = ({
  agentIdentifier,
  queryName,
  ...props
}: UseAgentApplicationServiceListResourceEventsProps) =>
  useGet<
    ApplicationsEventList,
    GatewayruntimeError,
    AgentApplicationServiceListResourceEventsQueryParams,
    AgentApplicationServiceListResourceEventsPathParams
  >(
    (paramsInPath: AgentApplicationServiceListResourceEventsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryName}/events`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryName }, ...props }
  )

export interface AgentApplicationServicePodLogs2Response {
  error?: RuntimeStreamError
  result?: ApplicationsLogEntry
}

export interface AgentApplicationServicePodLogs2QueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.namespace'?: string
  'query.podName'?: string
  'query.container'?: string
  'query.sinceSeconds'?: string
  /**
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   */
  'query.sinceTime.seconds'?: string
  /**
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive. This field may be limited in precision depending on context.
   */
  'query.sinceTime.nanos'?: number
  'query.tailLines'?: string
  'query.follow'?: boolean
  'query.untilTime'?: string
  'query.filter'?: string
  'query.kind'?: string
  'query.group'?: string
  'query.resourceName'?: string
  'query.previous'?: boolean
}

export interface AgentApplicationServicePodLogs2PathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  queryName: string
}

export type AgentApplicationServicePodLogs2Props = Omit<
  GetProps<
    AgentApplicationServicePodLogs2Response,
    GatewayruntimeError,
    AgentApplicationServicePodLogs2QueryParams,
    AgentApplicationServicePodLogs2PathParams
  >,
  'path'
> &
  AgentApplicationServicePodLogs2PathParams

/**
 * PodLogs returns stream of log entries for the specified pod(s).
 *
 * PodLogs returns stream of log entries for the specified pod(s).
 */
export const AgentApplicationServicePodLogs2 = ({
  agentIdentifier,
  queryName,
  ...props
}: AgentApplicationServicePodLogs2Props) => (
  <Get<
    AgentApplicationServicePodLogs2Response,
    GatewayruntimeError,
    AgentApplicationServicePodLogs2QueryParams,
    AgentApplicationServicePodLogs2PathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryName}/logs`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServicePodLogs2Props = Omit<
  UseGetProps<
    AgentApplicationServicePodLogs2Response,
    GatewayruntimeError,
    AgentApplicationServicePodLogs2QueryParams,
    AgentApplicationServicePodLogs2PathParams
  >,
  'path'
> &
  AgentApplicationServicePodLogs2PathParams

/**
 * PodLogs returns stream of log entries for the specified pod(s).
 *
 * PodLogs returns stream of log entries for the specified pod(s).
 */
export const useAgentApplicationServicePodLogs2 = ({
  agentIdentifier,
  queryName,
  ...props
}: UseAgentApplicationServicePodLogs2Props) =>
  useGet<
    AgentApplicationServicePodLogs2Response,
    GatewayruntimeError,
    AgentApplicationServicePodLogs2QueryParams,
    AgentApplicationServicePodLogs2PathParams
  >(
    (paramsInPath: AgentApplicationServicePodLogs2PathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryName}/logs`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryName }, ...props }
  )

export interface AgentApplicationServiceGetManifestsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.revision'?: string
}

export interface AgentApplicationServiceGetManifestsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  queryName: string
}

export type AgentApplicationServiceGetManifestsProps = Omit<
  GetProps<
    RepositoriesManifestResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetManifestsQueryParams,
    AgentApplicationServiceGetManifestsPathParams
  >,
  'path'
> &
  AgentApplicationServiceGetManifestsPathParams

/**
 * GetManifests returns application manifests
 *
 * GetManifests returns application manifests.
 */
export const AgentApplicationServiceGetManifests = ({
  agentIdentifier,
  queryName,
  ...props
}: AgentApplicationServiceGetManifestsProps) => (
  <Get<
    RepositoriesManifestResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetManifestsQueryParams,
    AgentApplicationServiceGetManifestsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryName}/manifests`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceGetManifestsProps = Omit<
  UseGetProps<
    RepositoriesManifestResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetManifestsQueryParams,
    AgentApplicationServiceGetManifestsPathParams
  >,
  'path'
> &
  AgentApplicationServiceGetManifestsPathParams

/**
 * GetManifests returns application manifests
 *
 * GetManifests returns application manifests.
 */
export const useAgentApplicationServiceGetManifests = ({
  agentIdentifier,
  queryName,
  ...props
}: UseAgentApplicationServiceGetManifestsProps) =>
  useGet<
    RepositoriesManifestResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetManifestsQueryParams,
    AgentApplicationServiceGetManifestsPathParams
  >(
    (paramsInPath: AgentApplicationServiceGetManifestsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryName}/manifests`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryName }, ...props }
  )

export interface AgentApplicationServicePodLogsResponse {
  error?: RuntimeStreamError
  result?: ApplicationsLogEntry
}

export interface AgentApplicationServicePodLogsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.namespace'?: string
  'query.container'?: string
  'query.sinceSeconds'?: string
  /**
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   */
  'query.sinceTime.seconds'?: string
  /**
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive. This field may be limited in precision depending on context.
   */
  'query.sinceTime.nanos'?: number
  'query.tailLines'?: string
  'query.follow'?: boolean
  'query.untilTime'?: string
  'query.filter'?: string
  'query.kind'?: string
  'query.group'?: string
  'query.resourceName'?: string
  'query.previous'?: boolean
}

export interface AgentApplicationServicePodLogsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  queryName: string
  queryPodName: string
}

export type AgentApplicationServicePodLogsProps = Omit<
  GetProps<
    AgentApplicationServicePodLogsResponse,
    GatewayruntimeError,
    AgentApplicationServicePodLogsQueryParams,
    AgentApplicationServicePodLogsPathParams
  >,
  'path'
> &
  AgentApplicationServicePodLogsPathParams

/**
 * PodLogs returns stream of log entries for the specified pod(s).
 *
 * PodLogs returns stream of log entries for the specified pod(s).
 */
export const AgentApplicationServicePodLogs = ({
  agentIdentifier,
  queryName,
  queryPodName,
  ...props
}: AgentApplicationServicePodLogsProps) => (
  <Get<
    AgentApplicationServicePodLogsResponse,
    GatewayruntimeError,
    AgentApplicationServicePodLogsQueryParams,
    AgentApplicationServicePodLogsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryName}/pods/${queryPodName}/logs`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServicePodLogsProps = Omit<
  UseGetProps<
    AgentApplicationServicePodLogsResponse,
    GatewayruntimeError,
    AgentApplicationServicePodLogsQueryParams,
    AgentApplicationServicePodLogsPathParams
  >,
  'path'
> &
  AgentApplicationServicePodLogsPathParams

/**
 * PodLogs returns stream of log entries for the specified pod(s).
 *
 * PodLogs returns stream of log entries for the specified pod(s).
 */
export const useAgentApplicationServicePodLogs = ({
  agentIdentifier,
  queryName,
  queryPodName,
  ...props
}: UseAgentApplicationServicePodLogsProps) =>
  useGet<
    AgentApplicationServicePodLogsResponse,
    GatewayruntimeError,
    AgentApplicationServicePodLogsQueryParams,
    AgentApplicationServicePodLogsPathParams
  >(
    (paramsInPath: AgentApplicationServicePodLogsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryName}/pods/${paramsInPath.queryPodName}/logs`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryName, queryPodName }, ...props }
  )

export interface AgentApplicationServiceResourceTreeQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.applicationName'?: string
  'query.namespace'?: string
  'query.version'?: string
  'query.group'?: string
  'query.kind'?: string
}

export interface AgentApplicationServiceResourceTreePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  queryName: string
}

export type AgentApplicationServiceResourceTreeProps = Omit<
  GetProps<
    ApplicationsApplicationTree,
    GatewayruntimeError,
    AgentApplicationServiceResourceTreeQueryParams,
    AgentApplicationServiceResourceTreePathParams
  >,
  'path'
> &
  AgentApplicationServiceResourceTreePathParams

/**
 * ResourceTree returns resource tree
 *
 * ResourceTree returns resource tree.
 */
export const AgentApplicationServiceResourceTree = ({
  agentIdentifier,
  queryName,
  ...props
}: AgentApplicationServiceResourceTreeProps) => (
  <Get<
    ApplicationsApplicationTree,
    GatewayruntimeError,
    AgentApplicationServiceResourceTreeQueryParams,
    AgentApplicationServiceResourceTreePathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryName}/resource-tree`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceResourceTreeProps = Omit<
  UseGetProps<
    ApplicationsApplicationTree,
    GatewayruntimeError,
    AgentApplicationServiceResourceTreeQueryParams,
    AgentApplicationServiceResourceTreePathParams
  >,
  'path'
> &
  AgentApplicationServiceResourceTreePathParams

/**
 * ResourceTree returns resource tree
 *
 * ResourceTree returns resource tree.
 */
export const useAgentApplicationServiceResourceTree = ({
  agentIdentifier,
  queryName,
  ...props
}: UseAgentApplicationServiceResourceTreeProps) =>
  useGet<
    ApplicationsApplicationTree,
    GatewayruntimeError,
    AgentApplicationServiceResourceTreeQueryParams,
    AgentApplicationServiceResourceTreePathParams
  >(
    (paramsInPath: AgentApplicationServiceResourceTreePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryName}/resource-tree`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryName }, ...props }
  )

export interface AgentApplicationServiceRevisionMetadataQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentApplicationServiceRevisionMetadataPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  /**
   * the application's name
   */
  queryName: string
  /**
   * the revision of the app
   */
  queryRevision: string
}

export type AgentApplicationServiceRevisionMetadataProps = Omit<
  GetProps<
    RepositoriesRevisionMetadata,
    GatewayruntimeError,
    AgentApplicationServiceRevisionMetadataQueryParams,
    AgentApplicationServiceRevisionMetadataPathParams
  >,
  'path'
> &
  AgentApplicationServiceRevisionMetadataPathParams

/**
 * Get the meta-data (author, date, tags, message) for a specific revision of the application
 *
 * RevisionMetadata returns metadata for a specific revision of the application.
 */
export const AgentApplicationServiceRevisionMetadata = ({
  agentIdentifier,
  queryName,
  queryRevision,
  ...props
}: AgentApplicationServiceRevisionMetadataProps) => (
  <Get<
    RepositoriesRevisionMetadata,
    GatewayruntimeError,
    AgentApplicationServiceRevisionMetadataQueryParams,
    AgentApplicationServiceRevisionMetadataPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryName}/revisions/${queryRevision}/metadata`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceRevisionMetadataProps = Omit<
  UseGetProps<
    RepositoriesRevisionMetadata,
    GatewayruntimeError,
    AgentApplicationServiceRevisionMetadataQueryParams,
    AgentApplicationServiceRevisionMetadataPathParams
  >,
  'path'
> &
  AgentApplicationServiceRevisionMetadataPathParams

/**
 * Get the meta-data (author, date, tags, message) for a specific revision of the application
 *
 * RevisionMetadata returns metadata for a specific revision of the application.
 */
export const useAgentApplicationServiceRevisionMetadata = ({
  agentIdentifier,
  queryName,
  queryRevision,
  ...props
}: UseAgentApplicationServiceRevisionMetadataProps) =>
  useGet<
    RepositoriesRevisionMetadata,
    GatewayruntimeError,
    AgentApplicationServiceRevisionMetadataQueryParams,
    AgentApplicationServiceRevisionMetadataPathParams
  >(
    (paramsInPath: AgentApplicationServiceRevisionMetadataPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryName}/revisions/${paramsInPath.queryRevision}/metadata`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryName, queryRevision }, ...props }
  )

export interface AgentApplicationServiceGetApplicationSyncWindowsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentApplicationServiceGetApplicationSyncWindowsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  queryName: string
}

export type AgentApplicationServiceGetApplicationSyncWindowsProps = Omit<
  GetProps<
    ApplicationsApplicationSyncWindowsResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetApplicationSyncWindowsQueryParams,
    AgentApplicationServiceGetApplicationSyncWindowsPathParams
  >,
  'path'
> &
  AgentApplicationServiceGetApplicationSyncWindowsPathParams

/**
 * Get returns sync windows of the application
 *
 * GetApplicationSyncWindows returns sync windows of the application.
 */
export const AgentApplicationServiceGetApplicationSyncWindows = ({
  agentIdentifier,
  queryName,
  ...props
}: AgentApplicationServiceGetApplicationSyncWindowsProps) => (
  <Get<
    ApplicationsApplicationSyncWindowsResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetApplicationSyncWindowsQueryParams,
    AgentApplicationServiceGetApplicationSyncWindowsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${queryName}/syncwindows`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceGetApplicationSyncWindowsProps = Omit<
  UseGetProps<
    ApplicationsApplicationSyncWindowsResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetApplicationSyncWindowsQueryParams,
    AgentApplicationServiceGetApplicationSyncWindowsPathParams
  >,
  'path'
> &
  AgentApplicationServiceGetApplicationSyncWindowsPathParams

/**
 * Get returns sync windows of the application
 *
 * GetApplicationSyncWindows returns sync windows of the application.
 */
export const useAgentApplicationServiceGetApplicationSyncWindows = ({
  agentIdentifier,
  queryName,
  ...props
}: UseAgentApplicationServiceGetApplicationSyncWindowsProps) =>
  useGet<
    ApplicationsApplicationSyncWindowsResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetApplicationSyncWindowsQueryParams,
    AgentApplicationServiceGetApplicationSyncWindowsPathParams
  >(
    (paramsInPath: AgentApplicationServiceGetApplicationSyncWindowsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.queryName}/syncwindows`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryName }, ...props }
  )

export interface AgentApplicationServiceUpdateQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  clusterIdentifier?: string
  repoIdentifier?: string
}

export interface AgentApplicationServiceUpdatePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   * +optional
   */
  requestApplicationMetadataName: string
}

export type AgentApplicationServiceUpdateProps = Omit<
  MutateProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceUpdateQueryParams,
    ApplicationsApplicationUpdateRequest,
    AgentApplicationServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceUpdatePathParams

/**
 * Update updates an application
 *
 * Update updates an application.
 */
export const AgentApplicationServiceUpdate = ({
  agentIdentifier,
  requestApplicationMetadataName,
  ...props
}: AgentApplicationServiceUpdateProps) => (
  <Mutate<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceUpdateQueryParams,
    ApplicationsApplicationUpdateRequest,
    AgentApplicationServiceUpdatePathParams
  >
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestApplicationMetadataName}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceUpdateProps = Omit<
  UseMutateProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceUpdateQueryParams,
    ApplicationsApplicationUpdateRequest,
    AgentApplicationServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceUpdatePathParams

/**
 * Update updates an application
 *
 * Update updates an application.
 */
export const useAgentApplicationServiceUpdate = ({
  agentIdentifier,
  requestApplicationMetadataName,
  ...props
}: UseAgentApplicationServiceUpdateProps) =>
  useMutate<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceUpdateQueryParams,
    ApplicationsApplicationUpdateRequest,
    AgentApplicationServiceUpdatePathParams
  >(
    'PUT',
    (paramsInPath: AgentApplicationServiceUpdatePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestApplicationMetadataName}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestApplicationMetadataName }, ...props }
  )

export interface AgentApplicationServiceDeleteQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'request.cascade'?: boolean
  'request.propagationPolicy'?: string
  'options.removeExistingFinalizers'?: boolean
}

export interface AgentApplicationServiceDeletePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentApplicationServiceDeleteProps = Omit<
  MutateProps<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceDeleteQueryParams,
    string,
    AgentApplicationServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceDeletePathParams

/**
 * Delete deletes an application
 *
 * Delete deletes an application.
 */
export const AgentApplicationServiceDelete = ({ agentIdentifier, ...props }: AgentApplicationServiceDeleteProps) => (
  <Mutate<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceDeleteQueryParams,
    string,
    AgentApplicationServiceDeletePathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/applications`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceDeleteProps = Omit<
  UseMutateProps<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceDeleteQueryParams,
    string,
    AgentApplicationServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceDeletePathParams

/**
 * Delete deletes an application
 *
 * Delete deletes an application.
 */
export const useAgentApplicationServiceDelete = ({
  agentIdentifier,
  ...props
}: UseAgentApplicationServiceDeleteProps) =>
  useMutate<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceDeleteQueryParams,
    string,
    AgentApplicationServiceDeletePathParams
  >(
    'DELETE',
    (paramsInPath: AgentApplicationServiceDeletePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentApplicationServicePatchPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServicePatchProps = Omit<
  MutateProps<
    Servicev1Application,
    GatewayruntimeError,
    void,
    Servicev1ApplicationPatchRequest,
    AgentApplicationServicePatchPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServicePatchPathParams

/**
 * Patch patch an application
 *
 * Patch applys a patches to an application.
 */
export const AgentApplicationServicePatch = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServicePatchProps) => (
  <Mutate<
    Servicev1Application,
    GatewayruntimeError,
    void,
    Servicev1ApplicationPatchRequest,
    AgentApplicationServicePatchPathParams
  >
    verb="PATCH"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServicePatchProps = Omit<
  UseMutateProps<
    Servicev1Application,
    GatewayruntimeError,
    void,
    Servicev1ApplicationPatchRequest,
    AgentApplicationServicePatchPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServicePatchPathParams

/**
 * Patch patch an application
 *
 * Patch applys a patches to an application.
 */
export const useAgentApplicationServicePatch = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServicePatchProps) =>
  useMutate<
    Servicev1Application,
    GatewayruntimeError,
    void,
    Servicev1ApplicationPatchRequest,
    AgentApplicationServicePatchPathParams
  >(
    'PATCH',
    (paramsInPath: AgentApplicationServicePatchPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AgentApplicationServiceTerminateOperationQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentApplicationServiceTerminateOperationPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServiceTerminateOperationProps = Omit<
  MutateProps<
    ApplicationsOperationTerminateResponse,
    GatewayruntimeError,
    AgentApplicationServiceTerminateOperationQueryParams,
    void,
    AgentApplicationServiceTerminateOperationPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceTerminateOperationPathParams

/**
 * TerminateOperation terminates the currently running operation
 *
 * TerminateOperation terminates the currently running operation.
 */
export const AgentApplicationServiceTerminateOperation = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServiceTerminateOperationProps) => (
  <Mutate<
    ApplicationsOperationTerminateResponse,
    GatewayruntimeError,
    AgentApplicationServiceTerminateOperationQueryParams,
    void,
    AgentApplicationServiceTerminateOperationPathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/operation`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceTerminateOperationProps = Omit<
  UseMutateProps<
    ApplicationsOperationTerminateResponse,
    GatewayruntimeError,
    AgentApplicationServiceTerminateOperationQueryParams,
    void,
    AgentApplicationServiceTerminateOperationPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceTerminateOperationPathParams

/**
 * TerminateOperation terminates the currently running operation
 *
 * TerminateOperation terminates the currently running operation.
 */
export const useAgentApplicationServiceTerminateOperation = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServiceTerminateOperationProps) =>
  useMutate<
    ApplicationsOperationTerminateResponse,
    GatewayruntimeError,
    AgentApplicationServiceTerminateOperationQueryParams,
    void,
    AgentApplicationServiceTerminateOperationPathParams
  >(
    'DELETE',
    (paramsInPath: AgentApplicationServiceTerminateOperationPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/operation`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AgentApplicationServiceDeleteResourceQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'request.namespace'?: string
  'request.resourceName'?: string
  'request.version'?: string
  'request.group'?: string
  'request.kind'?: string
  'request.force'?: boolean
  'request.orphan'?: boolean
}

export interface AgentApplicationServiceDeleteResourcePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServiceDeleteResourceProps = Omit<
  MutateProps<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceDeleteResourceQueryParams,
    void,
    AgentApplicationServiceDeleteResourcePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceDeleteResourcePathParams

/**
 * DeleteResource deletes a single application resource
 *
 * DeleteResource deletes a single application resource.
 */
export const AgentApplicationServiceDeleteResource = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServiceDeleteResourceProps) => (
  <Mutate<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceDeleteResourceQueryParams,
    void,
    AgentApplicationServiceDeleteResourcePathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/resource`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceDeleteResourceProps = Omit<
  UseMutateProps<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceDeleteResourceQueryParams,
    void,
    AgentApplicationServiceDeleteResourcePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceDeleteResourcePathParams

/**
 * DeleteResource deletes a single application resource
 *
 * DeleteResource deletes a single application resource.
 */
export const useAgentApplicationServiceDeleteResource = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServiceDeleteResourceProps) =>
  useMutate<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceDeleteResourceQueryParams,
    void,
    AgentApplicationServiceDeleteResourcePathParams
  >(
    'DELETE',
    (paramsInPath: AgentApplicationServiceDeleteResourcePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/resource`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AgentApplicationServiceGetResourceQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'request.namespace'?: string
  'request.resourceName'?: string
  'request.version'?: string
  'request.group'?: string
  'request.kind'?: string
}

export interface AgentApplicationServiceGetResourcePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServiceGetResourceProps = Omit<
  GetProps<
    ApplicationsApplicationResourceResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetResourceQueryParams,
    AgentApplicationServiceGetResourcePathParams
  >,
  'path'
> &
  AgentApplicationServiceGetResourcePathParams

/**
 * GetResource returns single application resource
 *
 * GetResource returns single application resource.
 */
export const AgentApplicationServiceGetResource = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServiceGetResourceProps) => (
  <Get<
    ApplicationsApplicationResourceResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetResourceQueryParams,
    AgentApplicationServiceGetResourcePathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/resource`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceGetResourceProps = Omit<
  UseGetProps<
    ApplicationsApplicationResourceResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetResourceQueryParams,
    AgentApplicationServiceGetResourcePathParams
  >,
  'path'
> &
  AgentApplicationServiceGetResourcePathParams

/**
 * GetResource returns single application resource
 *
 * GetResource returns single application resource.
 */
export const useAgentApplicationServiceGetResource = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServiceGetResourceProps) =>
  useGet<
    ApplicationsApplicationResourceResponse,
    GatewayruntimeError,
    AgentApplicationServiceGetResourceQueryParams,
    AgentApplicationServiceGetResourcePathParams
  >(
    (paramsInPath: AgentApplicationServiceGetResourcePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/resource`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AgentApplicationServicePatchResourceQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentApplicationServicePatchResourcePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServicePatchResourceProps = Omit<
  MutateProps<
    ApplicationsApplicationResourceResponse,
    GatewayruntimeError,
    AgentApplicationServicePatchResourceQueryParams,
    ApplicationsApplicationResourcePatchRequest,
    AgentApplicationServicePatchResourcePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServicePatchResourcePathParams

/**
 * PatchResource patch single application resource
 *
 * PatchResource patch single application resource.
 */
export const AgentApplicationServicePatchResource = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServicePatchResourceProps) => (
  <Mutate<
    ApplicationsApplicationResourceResponse,
    GatewayruntimeError,
    AgentApplicationServicePatchResourceQueryParams,
    ApplicationsApplicationResourcePatchRequest,
    AgentApplicationServicePatchResourcePathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/resource`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServicePatchResourceProps = Omit<
  UseMutateProps<
    ApplicationsApplicationResourceResponse,
    GatewayruntimeError,
    AgentApplicationServicePatchResourceQueryParams,
    ApplicationsApplicationResourcePatchRequest,
    AgentApplicationServicePatchResourcePathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServicePatchResourcePathParams

/**
 * PatchResource patch single application resource
 *
 * PatchResource patch single application resource.
 */
export const useAgentApplicationServicePatchResource = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServicePatchResourceProps) =>
  useMutate<
    ApplicationsApplicationResourceResponse,
    GatewayruntimeError,
    AgentApplicationServicePatchResourceQueryParams,
    ApplicationsApplicationResourcePatchRequest,
    AgentApplicationServicePatchResourcePathParams
  >(
    'POST',
    (paramsInPath: AgentApplicationServicePatchResourcePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/resource`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AgentApplicationServiceListResourceActionsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'request.namespace'?: string
  'request.resourceName'?: string
  'request.version'?: string
  'request.group'?: string
  'request.kind'?: string
}

export interface AgentApplicationServiceListResourceActionsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServiceListResourceActionsProps = Omit<
  GetProps<
    ApplicationsResourceActionsListResponse,
    GatewayruntimeError,
    AgentApplicationServiceListResourceActionsQueryParams,
    AgentApplicationServiceListResourceActionsPathParams
  >,
  'path'
> &
  AgentApplicationServiceListResourceActionsPathParams

/**
 * ListResourceActions returns list of resource actions
 *
 * ListResourceActions returns list of resource actions.
 */
export const AgentApplicationServiceListResourceActions = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServiceListResourceActionsProps) => (
  <Get<
    ApplicationsResourceActionsListResponse,
    GatewayruntimeError,
    AgentApplicationServiceListResourceActionsQueryParams,
    AgentApplicationServiceListResourceActionsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/resource/actions`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceListResourceActionsProps = Omit<
  UseGetProps<
    ApplicationsResourceActionsListResponse,
    GatewayruntimeError,
    AgentApplicationServiceListResourceActionsQueryParams,
    AgentApplicationServiceListResourceActionsPathParams
  >,
  'path'
> &
  AgentApplicationServiceListResourceActionsPathParams

/**
 * ListResourceActions returns list of resource actions
 *
 * ListResourceActions returns list of resource actions.
 */
export const useAgentApplicationServiceListResourceActions = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServiceListResourceActionsProps) =>
  useGet<
    ApplicationsResourceActionsListResponse,
    GatewayruntimeError,
    AgentApplicationServiceListResourceActionsQueryParams,
    AgentApplicationServiceListResourceActionsPathParams
  >(
    (paramsInPath: AgentApplicationServiceListResourceActionsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/resource/actions`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AgentApplicationServiceRunResourceActionQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentApplicationServiceRunResourceActionPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServiceRunResourceActionProps = Omit<
  MutateProps<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceRunResourceActionQueryParams,
    ApplicationsResourceActionRunRequest,
    AgentApplicationServiceRunResourceActionPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceRunResourceActionPathParams

/**
 * RunResourceAction run resource action
 *
 * RunResourceAction run resource action.
 */
export const AgentApplicationServiceRunResourceAction = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServiceRunResourceActionProps) => (
  <Mutate<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceRunResourceActionQueryParams,
    ApplicationsResourceActionRunRequest,
    AgentApplicationServiceRunResourceActionPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/resource/actions`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceRunResourceActionProps = Omit<
  UseMutateProps<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceRunResourceActionQueryParams,
    ApplicationsResourceActionRunRequest,
    AgentApplicationServiceRunResourceActionPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceRunResourceActionPathParams

/**
 * RunResourceAction run resource action
 *
 * RunResourceAction run resource action.
 */
export const useAgentApplicationServiceRunResourceAction = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServiceRunResourceActionProps) =>
  useMutate<
    ApplicationsApplicationResponse,
    GatewayruntimeError,
    AgentApplicationServiceRunResourceActionQueryParams,
    ApplicationsResourceActionRunRequest,
    AgentApplicationServiceRunResourceActionPathParams
  >(
    'POST',
    (paramsInPath: AgentApplicationServiceRunResourceActionPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/resource/actions`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AgentApplicationServiceRollbackQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentApplicationServiceRollbackPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServiceRollbackProps = Omit<
  MutateProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceRollbackQueryParams,
    ApplicationsApplicationRollbackRequest,
    AgentApplicationServiceRollbackPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceRollbackPathParams

/**
 * Rollback syncs an application to its target state
 * Harness Event type (rollback)
 *
 * Rollback syncs an application to its target state
 * Harness Event type (rollback).
 */
export const AgentApplicationServiceRollback = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServiceRollbackProps) => (
  <Mutate<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceRollbackQueryParams,
    ApplicationsApplicationRollbackRequest,
    AgentApplicationServiceRollbackPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/rollback`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceRollbackProps = Omit<
  UseMutateProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceRollbackQueryParams,
    ApplicationsApplicationRollbackRequest,
    AgentApplicationServiceRollbackPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceRollbackPathParams

/**
 * Rollback syncs an application to its target state
 * Harness Event type (rollback)
 *
 * Rollback syncs an application to its target state
 * Harness Event type (rollback).
 */
export const useAgentApplicationServiceRollback = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServiceRollbackProps) =>
  useMutate<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceRollbackQueryParams,
    ApplicationsApplicationRollbackRequest,
    AgentApplicationServiceRollbackPathParams
  >(
    'POST',
    (paramsInPath: AgentApplicationServiceRollbackPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/rollback`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface RolloutsServiceGetRolloutStatusQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'request.namespace'?: string
  'request.resourceName'?: string
  'request.version'?: string
  'request.group'?: string
  'request.kind'?: string
}

export interface RolloutsServiceGetRolloutStatusPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type RolloutsServiceGetRolloutStatusProps = Omit<
  GetProps<
    V1RolloutInfo,
    GatewayruntimeError,
    RolloutsServiceGetRolloutStatusQueryParams,
    RolloutsServiceGetRolloutStatusPathParams
  >,
  'path'
> &
  RolloutsServiceGetRolloutStatusPathParams

/**
 * Get current status for the given Rollout resource
 */
export const RolloutsServiceGetRolloutStatus = ({
  agentIdentifier,
  requestName,
  ...props
}: RolloutsServiceGetRolloutStatusProps) => (
  <Get<
    V1RolloutInfo,
    GatewayruntimeError,
    RolloutsServiceGetRolloutStatusQueryParams,
    RolloutsServiceGetRolloutStatusPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/rollouts/status`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseRolloutsServiceGetRolloutStatusProps = Omit<
  UseGetProps<
    V1RolloutInfo,
    GatewayruntimeError,
    RolloutsServiceGetRolloutStatusQueryParams,
    RolloutsServiceGetRolloutStatusPathParams
  >,
  'path'
> &
  RolloutsServiceGetRolloutStatusPathParams

/**
 * Get current status for the given Rollout resource
 */
export const useRolloutsServiceGetRolloutStatus = ({
  agentIdentifier,
  requestName,
  ...props
}: UseRolloutsServiceGetRolloutStatusProps) =>
  useGet<
    V1RolloutInfo,
    GatewayruntimeError,
    RolloutsServiceGetRolloutStatusQueryParams,
    RolloutsServiceGetRolloutStatusPathParams
  >(
    (paramsInPath: RolloutsServiceGetRolloutStatusPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/rollouts/status`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AgentApplicationServiceUpdateSpecQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentApplicationServiceUpdateSpecPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServiceUpdateSpecProps = Omit<
  MutateProps<
    ApplicationsApplicationSpec,
    GatewayruntimeError,
    AgentApplicationServiceUpdateSpecQueryParams,
    ApplicationsApplicationUpdateSpecRequest,
    AgentApplicationServiceUpdateSpecPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceUpdateSpecPathParams

/**
 * UpdateSpec updates an application spec
 *
 * UpdateSpec updates an application spec.
 */
export const AgentApplicationServiceUpdateSpec = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServiceUpdateSpecProps) => (
  <Mutate<
    ApplicationsApplicationSpec,
    GatewayruntimeError,
    AgentApplicationServiceUpdateSpecQueryParams,
    ApplicationsApplicationUpdateSpecRequest,
    AgentApplicationServiceUpdateSpecPathParams
  >
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/spec`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceUpdateSpecProps = Omit<
  UseMutateProps<
    ApplicationsApplicationSpec,
    GatewayruntimeError,
    AgentApplicationServiceUpdateSpecQueryParams,
    ApplicationsApplicationUpdateSpecRequest,
    AgentApplicationServiceUpdateSpecPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceUpdateSpecPathParams

/**
 * UpdateSpec updates an application spec
 *
 * UpdateSpec updates an application spec.
 */
export const useAgentApplicationServiceUpdateSpec = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServiceUpdateSpecProps) =>
  useMutate<
    ApplicationsApplicationSpec,
    GatewayruntimeError,
    AgentApplicationServiceUpdateSpecQueryParams,
    ApplicationsApplicationUpdateSpecRequest,
    AgentApplicationServiceUpdateSpecPathParams
  >(
    'PUT',
    (paramsInPath: AgentApplicationServiceUpdateSpecPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/spec`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AgentApplicationServiceSyncQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentApplicationServiceSyncPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  requestName: string
}

export type AgentApplicationServiceSyncProps = Omit<
  MutateProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceSyncQueryParams,
    ApplicationsApplicationSyncRequest,
    AgentApplicationServiceSyncPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceSyncPathParams

/**
 * Sync syncs an application to its target state
 * Harness Event type (deploy)
 *
 * Delete deletes an application.
 */
export const AgentApplicationServiceSync = ({
  agentIdentifier,
  requestName,
  ...props
}: AgentApplicationServiceSyncProps) => (
  <Mutate<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceSyncQueryParams,
    ApplicationsApplicationSyncRequest,
    AgentApplicationServiceSyncPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/applications/${requestName}/sync`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceSyncProps = Omit<
  UseMutateProps<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceSyncQueryParams,
    ApplicationsApplicationSyncRequest,
    AgentApplicationServiceSyncPathParams
  >,
  'path' | 'verb'
> &
  AgentApplicationServiceSyncPathParams

/**
 * Sync syncs an application to its target state
 * Harness Event type (deploy)
 *
 * Delete deletes an application.
 */
export const useAgentApplicationServiceSync = ({
  agentIdentifier,
  requestName,
  ...props
}: UseAgentApplicationServiceSyncProps) =>
  useMutate<
    Servicev1Application,
    GatewayruntimeError,
    AgentApplicationServiceSyncQueryParams,
    ApplicationsApplicationSyncRequest,
    AgentApplicationServiceSyncPathParams
  >(
    'POST',
    (paramsInPath: AgentApplicationServiceSyncPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/applications/${paramsInPath.requestName}/sync`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestName }, ...props }
  )

export interface AppProjectMappingServiceGetAppProjectMappingListByAgentQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AppProjectMappingServiceGetAppProjectMappingListByAgentPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AppProjectMappingServiceGetAppProjectMappingListByAgentProps = Omit<
  GetProps<
    Servicev1AppProjectMapping,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingListByAgentQueryParams,
    AppProjectMappingServiceGetAppProjectMappingListByAgentPathParams
  >,
  'path'
> &
  AppProjectMappingServiceGetAppProjectMappingListByAgentPathParams

/**
 * Retrieves Harness-Argo project mappings list by agent.
 */
export const AppProjectMappingServiceGetAppProjectMappingListByAgent = ({
  agentIdentifier,
  ...props
}: AppProjectMappingServiceGetAppProjectMappingListByAgentProps) => (
  <Get<
    Servicev1AppProjectMapping,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingListByAgentQueryParams,
    AppProjectMappingServiceGetAppProjectMappingListByAgentPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/appprojectsmapping`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAppProjectMappingServiceGetAppProjectMappingListByAgentProps = Omit<
  UseGetProps<
    Servicev1AppProjectMapping,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingListByAgentQueryParams,
    AppProjectMappingServiceGetAppProjectMappingListByAgentPathParams
  >,
  'path'
> &
  AppProjectMappingServiceGetAppProjectMappingListByAgentPathParams

/**
 * Retrieves Harness-Argo project mappings list by agent.
 */
export const useAppProjectMappingServiceGetAppProjectMappingListByAgent = ({
  agentIdentifier,
  ...props
}: UseAppProjectMappingServiceGetAppProjectMappingListByAgentProps) =>
  useGet<
    Servicev1AppProjectMapping,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingListByAgentQueryParams,
    AppProjectMappingServiceGetAppProjectMappingListByAgentPathParams
  >(
    (paramsInPath: AppProjectMappingServiceGetAppProjectMappingListByAgentPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/appprojectsmapping`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AppProjectMappingServiceCreateQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AppProjectMappingServiceCreatePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AppProjectMappingServiceCreateProps = Omit<
  MutateProps<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceCreateQueryParams,
    Servicev1AppProjectMapping,
    AppProjectMappingServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceCreatePathParams

/**
 * CreateAppProjectMapping creates a new mapping between Harness Project and argo project
 *
 * Creates Harness-Argo project mappings.
 */
export const AppProjectMappingServiceCreate = ({ agentIdentifier, ...props }: AppProjectMappingServiceCreateProps) => (
  <Mutate<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceCreateQueryParams,
    Servicev1AppProjectMapping,
    AppProjectMappingServiceCreatePathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/appprojectsmapping`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAppProjectMappingServiceCreateProps = Omit<
  UseMutateProps<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceCreateQueryParams,
    Servicev1AppProjectMapping,
    AppProjectMappingServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceCreatePathParams

/**
 * CreateAppProjectMapping creates a new mapping between Harness Project and argo project
 *
 * Creates Harness-Argo project mappings.
 */
export const useAppProjectMappingServiceCreate = ({
  agentIdentifier,
  ...props
}: UseAppProjectMappingServiceCreateProps) =>
  useMutate<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceCreateQueryParams,
    Servicev1AppProjectMapping,
    AppProjectMappingServiceCreatePathParams
  >(
    'POST',
    (paramsInPath: AppProjectMappingServiceCreatePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/appprojectsmapping`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AppProjectMappingServiceDeleteQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AppProjectMappingServiceDeletePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AppProjectMappingServiceDeleteProps = Omit<
  MutateProps<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceDeleteQueryParams,
    string,
    AppProjectMappingServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceDeletePathParams

/**
 * Delete an argo project to harness project mapping
 *
 * Delete Harness-Argo project mappings.
 */
export const AppProjectMappingServiceDelete = ({ agentIdentifier, ...props }: AppProjectMappingServiceDeleteProps) => (
  <Mutate<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceDeleteQueryParams,
    string,
    AppProjectMappingServiceDeletePathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/appprojectsmapping`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAppProjectMappingServiceDeleteProps = Omit<
  UseMutateProps<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceDeleteQueryParams,
    string,
    AppProjectMappingServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceDeletePathParams

/**
 * Delete an argo project to harness project mapping
 *
 * Delete Harness-Argo project mappings.
 */
export const useAppProjectMappingServiceDelete = ({
  agentIdentifier,
  ...props
}: UseAppProjectMappingServiceDeleteProps) =>
  useMutate<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceDeleteQueryParams,
    string,
    AppProjectMappingServiceDeletePathParams
  >(
    'DELETE',
    (paramsInPath: AppProjectMappingServiceDeletePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/appprojectsmapping`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentCertificateServiceDeleteQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  projectIdentifier?: string
  /**
   * A file-glob pattern (not regular expression) the host name has to match.
   */
  'query.hostNamePattern'?: string
  /**
   * The type of the certificate to match (ssh or https).
   */
  'query.certType'?: string
  /**
   * The sub type of the certificate to match (protocol dependent, usually only used for ssh certs).
   */
  'query.certSubType'?: string
}

export interface AgentCertificateServiceDeletePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentCertificateServiceDeleteProps = Omit<
  MutateProps<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceDeleteQueryParams,
    void,
    AgentCertificateServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentCertificateServiceDeletePathParams

/**
 * Delete the certificates that match the RepositoryCertificateQuery
 *
 * Delete repository certificates.
 */
export const AgentCertificateServiceDelete = ({ agentIdentifier, ...props }: AgentCertificateServiceDeleteProps) => (
  <Mutate<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceDeleteQueryParams,
    void,
    AgentCertificateServiceDeletePathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/certificates`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentCertificateServiceDeleteProps = Omit<
  UseMutateProps<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceDeleteQueryParams,
    void,
    AgentCertificateServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentCertificateServiceDeletePathParams

/**
 * Delete the certificates that match the RepositoryCertificateQuery
 *
 * Delete repository certificates.
 */
export const useAgentCertificateServiceDelete = ({
  agentIdentifier,
  ...props
}: UseAgentCertificateServiceDeleteProps) =>
  useMutate<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceDeleteQueryParams,
    void,
    AgentCertificateServiceDeletePathParams
  >(
    'DELETE',
    (paramsInPath: AgentCertificateServiceDeletePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/certificates`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentCertificateServiceListQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  projectIdentifier?: string
  /**
   * A file-glob pattern (not regular expression) the host name has to match.
   */
  'query.hostNamePattern'?: string
  /**
   * The type of the certificate to match (ssh or https).
   */
  'query.certType'?: string
  /**
   * The sub type of the certificate to match (protocol dependent, usually only used for ssh certs).
   */
  'query.certSubType'?: string
}

export interface AgentCertificateServiceListPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentCertificateServiceListProps = Omit<
  GetProps<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceListQueryParams,
    AgentCertificateServiceListPathParams
  >,
  'path'
> &
  AgentCertificateServiceListPathParams

/**
 * List all available repository certificates
 *
 * List repository certificates.
 */
export const AgentCertificateServiceList = ({ agentIdentifier, ...props }: AgentCertificateServiceListProps) => (
  <Get<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceListQueryParams,
    AgentCertificateServiceListPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/certificates`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentCertificateServiceListProps = Omit<
  UseGetProps<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceListQueryParams,
    AgentCertificateServiceListPathParams
  >,
  'path'
> &
  AgentCertificateServiceListPathParams

/**
 * List all available repository certificates
 *
 * List repository certificates.
 */
export const useAgentCertificateServiceList = ({ agentIdentifier, ...props }: UseAgentCertificateServiceListProps) =>
  useGet<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceListQueryParams,
    AgentCertificateServiceListPathParams
  >(
    (paramsInPath: AgentCertificateServiceListPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/certificates`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentCertificateServiceCreateQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentCertificateServiceCreatePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentCertificateServiceCreateProps = Omit<
  MutateProps<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceCreateQueryParams,
    CertificateRepositoryCertificateCreateRequest,
    AgentCertificateServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentCertificateServiceCreatePathParams

/**
 * Creates repository certificates on the server
 *
 * Create repository certificates.
 */
export const AgentCertificateServiceCreate = ({ agentIdentifier, ...props }: AgentCertificateServiceCreateProps) => (
  <Mutate<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceCreateQueryParams,
    CertificateRepositoryCertificateCreateRequest,
    AgentCertificateServiceCreatePathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/certificates`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentCertificateServiceCreateProps = Omit<
  UseMutateProps<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceCreateQueryParams,
    CertificateRepositoryCertificateCreateRequest,
    AgentCertificateServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentCertificateServiceCreatePathParams

/**
 * Creates repository certificates on the server
 *
 * Create repository certificates.
 */
export const useAgentCertificateServiceCreate = ({
  agentIdentifier,
  ...props
}: UseAgentCertificateServiceCreateProps) =>
  useMutate<
    CertificatesRepositoryCertificateList,
    GatewayruntimeError,
    AgentCertificateServiceCreateQueryParams,
    CertificateRepositoryCertificateCreateRequest,
    AgentCertificateServiceCreatePathParams
  >(
    'POST',
    (paramsInPath: AgentCertificateServiceCreatePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/certificates`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentClusterServiceListQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  identifier?: string
  'query.server'?: string
  'query.name'?: string
  /**
   * type is the type of the specified cluster identifier ( "server" - default, "name" ).
   */
  'query.id.type'?: string
  /**
   * value holds the cluster server URL or cluster name.
   */
  'query.id.value'?: string
  'query.project'?: string
}

export interface AgentClusterServiceListPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentClusterServiceListProps = Omit<
  GetProps<
    ClustersClusterList,
    GatewayruntimeError,
    AgentClusterServiceListQueryParams,
    AgentClusterServiceListPathParams
  >,
  'path'
> &
  AgentClusterServiceListPathParams

/**
 * List returns list of clusters
 *
 * List clusters.
 */
export const AgentClusterServiceList = ({ agentIdentifier, ...props }: AgentClusterServiceListProps) => (
  <Get<ClustersClusterList, GatewayruntimeError, AgentClusterServiceListQueryParams, AgentClusterServiceListPathParams>
    path={`/api/v1/agents/${agentIdentifier}/clusters`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentClusterServiceListProps = Omit<
  UseGetProps<
    ClustersClusterList,
    GatewayruntimeError,
    AgentClusterServiceListQueryParams,
    AgentClusterServiceListPathParams
  >,
  'path'
> &
  AgentClusterServiceListPathParams

/**
 * List returns list of clusters
 *
 * List clusters.
 */
export const useAgentClusterServiceList = ({ agentIdentifier, ...props }: UseAgentClusterServiceListProps) =>
  useGet<
    ClustersClusterList,
    GatewayruntimeError,
    AgentClusterServiceListQueryParams,
    AgentClusterServiceListPathParams
  >((paramsInPath: AgentClusterServiceListPathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters`, {
    base: window.getApiBaseUrl('gitops'),
    pathParams: { agentIdentifier },
    ...props
  })

export interface AgentClusterServiceCreateQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  identifier?: string
}

export interface AgentClusterServiceCreatePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentClusterServiceCreateProps = Omit<
  MutateProps<
    Servicev1Cluster,
    GatewayruntimeError,
    AgentClusterServiceCreateQueryParams,
    ClustersClusterCreateRequest,
    AgentClusterServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentClusterServiceCreatePathParams

/**
 * Create creates a cluster
 *
 * Create clusters.
 */
export const AgentClusterServiceCreate = ({ agentIdentifier, ...props }: AgentClusterServiceCreateProps) => (
  <Mutate<
    Servicev1Cluster,
    GatewayruntimeError,
    AgentClusterServiceCreateQueryParams,
    ClustersClusterCreateRequest,
    AgentClusterServiceCreatePathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/clusters`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentClusterServiceCreateProps = Omit<
  UseMutateProps<
    Servicev1Cluster,
    GatewayruntimeError,
    AgentClusterServiceCreateQueryParams,
    ClustersClusterCreateRequest,
    AgentClusterServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentClusterServiceCreatePathParams

/**
 * Create creates a cluster
 *
 * Create clusters.
 */
export const useAgentClusterServiceCreate = ({ agentIdentifier, ...props }: UseAgentClusterServiceCreateProps) =>
  useMutate<
    Servicev1Cluster,
    GatewayruntimeError,
    AgentClusterServiceCreateQueryParams,
    ClustersClusterCreateRequest,
    AgentClusterServiceCreatePathParams
  >(
    'POST',
    (paramsInPath: AgentClusterServiceCreatePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentClusterServiceDeleteQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.server'?: string
  'query.name'?: string
  /**
   * type is the type of the specified cluster identifier ( "server" - default, "name" ).
   */
  'query.id.type'?: string
  /**
   * value holds the cluster server URL or cluster name.
   */
  'query.id.value'?: string
  'query.project'?: string
}

export interface AgentClusterServiceDeletePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentClusterServiceDeleteProps = Omit<
  MutateProps<
    ClustersClusterResponse,
    GatewayruntimeError,
    AgentClusterServiceDeleteQueryParams,
    string,
    AgentClusterServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentClusterServiceDeletePathParams

/**
 * Delete deletes a cluster
 *
 * Delete cluster.
 */
export const AgentClusterServiceDelete = ({ agentIdentifier, ...props }: AgentClusterServiceDeleteProps) => (
  <Mutate<
    ClustersClusterResponse,
    GatewayruntimeError,
    AgentClusterServiceDeleteQueryParams,
    string,
    AgentClusterServiceDeletePathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/clusters`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentClusterServiceDeleteProps = Omit<
  UseMutateProps<
    ClustersClusterResponse,
    GatewayruntimeError,
    AgentClusterServiceDeleteQueryParams,
    string,
    AgentClusterServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentClusterServiceDeletePathParams

/**
 * Delete deletes a cluster
 *
 * Delete cluster.
 */
export const useAgentClusterServiceDelete = ({ agentIdentifier, ...props }: UseAgentClusterServiceDeleteProps) =>
  useMutate<
    ClustersClusterResponse,
    GatewayruntimeError,
    AgentClusterServiceDeleteQueryParams,
    string,
    AgentClusterServiceDeletePathParams
  >(
    'DELETE',
    (paramsInPath: AgentClusterServiceDeletePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentClusterServiceGetQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.server'?: string
  'query.name'?: string
  /**
   * type is the type of the specified cluster identifier ( "server" - default, "name" ).
   */
  'query.id.type'?: string
  /**
   * value holds the cluster server URL or cluster name.
   */
  'query.id.value'?: string
  'query.project'?: string
}

export interface AgentClusterServiceGetPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentClusterServiceGetProps = Omit<
  GetProps<Servicev1Cluster, GatewayruntimeError, AgentClusterServiceGetQueryParams, AgentClusterServiceGetPathParams>,
  'path'
> &
  AgentClusterServiceGetPathParams

/**
 * Get returns a cluster by identifier
 *
 * Get cluster.
 */
export const AgentClusterServiceGet = ({ agentIdentifier, identifier, ...props }: AgentClusterServiceGetProps) => (
  <Get<Servicev1Cluster, GatewayruntimeError, AgentClusterServiceGetQueryParams, AgentClusterServiceGetPathParams>
    path={`/api/v1/agents/${agentIdentifier}/clusters/${identifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentClusterServiceGetProps = Omit<
  UseGetProps<
    Servicev1Cluster,
    GatewayruntimeError,
    AgentClusterServiceGetQueryParams,
    AgentClusterServiceGetPathParams
  >,
  'path'
> &
  AgentClusterServiceGetPathParams

/**
 * Get returns a cluster by identifier
 *
 * Get cluster.
 */
export const useAgentClusterServiceGet = ({ agentIdentifier, identifier, ...props }: UseAgentClusterServiceGetProps) =>
  useGet<Servicev1Cluster, GatewayruntimeError, AgentClusterServiceGetQueryParams, AgentClusterServiceGetPathParams>(
    (paramsInPath: AgentClusterServiceGetPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters/${paramsInPath.identifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentClusterServiceUpdateQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentClusterServiceUpdatePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentClusterServiceUpdateProps = Omit<
  MutateProps<
    Servicev1Cluster,
    GatewayruntimeError,
    AgentClusterServiceUpdateQueryParams,
    ClustersClusterUpdateRequest,
    AgentClusterServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  AgentClusterServiceUpdatePathParams

/**
 * Update updates a cluster
 *
 * Update cluster.
 */
export const AgentClusterServiceUpdate = ({
  agentIdentifier,
  identifier,
  ...props
}: AgentClusterServiceUpdateProps) => (
  <Mutate<
    Servicev1Cluster,
    GatewayruntimeError,
    AgentClusterServiceUpdateQueryParams,
    ClustersClusterUpdateRequest,
    AgentClusterServiceUpdatePathParams
  >
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/clusters/${identifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentClusterServiceUpdateProps = Omit<
  UseMutateProps<
    Servicev1Cluster,
    GatewayruntimeError,
    AgentClusterServiceUpdateQueryParams,
    ClustersClusterUpdateRequest,
    AgentClusterServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  AgentClusterServiceUpdatePathParams

/**
 * Update updates a cluster
 *
 * Update cluster.
 */
export const useAgentClusterServiceUpdate = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAgentClusterServiceUpdateProps) =>
  useMutate<
    Servicev1Cluster,
    GatewayruntimeError,
    AgentClusterServiceUpdateQueryParams,
    ClustersClusterUpdateRequest,
    AgentClusterServiceUpdatePathParams
  >(
    'PUT',
    (paramsInPath: AgentClusterServiceUpdatePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/clusters/${paramsInPath.identifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentServiceForServerGetDeployYamlQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  namespace?: string
  /**
   * Disaster Recovery Identifier for entity.
   */
  disasterRecoveryIdentifier?: string
  skipCrds?: boolean
}

export interface AgentServiceForServerGetDeployYamlPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentServiceForServerGetDeployYamlProps = Omit<
  GetProps<void, void, AgentServiceForServerGetDeployYamlQueryParams, AgentServiceForServerGetDeployYamlPathParams>,
  'path'
> &
  AgentServiceForServerGetDeployYamlPathParams

/**
 * GetDeployYaml returns depoyment yamls for agents.
 */
export const AgentServiceForServerGetDeployYaml = ({
  agentIdentifier,
  ...props
}: AgentServiceForServerGetDeployYamlProps) => (
  <Get<void, void, AgentServiceForServerGetDeployYamlQueryParams, AgentServiceForServerGetDeployYamlPathParams>
    path={`/api/v1/agents/${agentIdentifier}/deploy.yaml`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerGetDeployYamlProps = Omit<
  UseGetProps<void, void, AgentServiceForServerGetDeployYamlQueryParams, AgentServiceForServerGetDeployYamlPathParams>,
  'path'
> &
  AgentServiceForServerGetDeployYamlPathParams

/**
 * GetDeployYaml returns depoyment yamls for agents.
 */
export const useAgentServiceForServerGetDeployYaml = ({
  agentIdentifier,
  ...props
}: UseAgentServiceForServerGetDeployYamlProps) =>
  useGet<void, void, AgentServiceForServerGetDeployYamlQueryParams, AgentServiceForServerGetDeployYamlPathParams>(
    (paramsInPath: AgentServiceForServerGetDeployYamlPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/deploy.yaml`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentGPGKeyServiceListQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * The GPG key ID to query for.
   */
  'query.keyID'?: string
}

export interface AgentGPGKeyServiceListPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentGPGKeyServiceListProps = Omit<
  GetProps<
    GpgkeysGnuPGPublicKeyList,
    GatewayruntimeError,
    AgentGPGKeyServiceListQueryParams,
    AgentGPGKeyServiceListPathParams
  >,
  'path'
> &
  AgentGPGKeyServiceListPathParams

/**
 * List all available repository certificates
 *
 * List all available repository certificates.
 */
export const AgentGPGKeyServiceList = ({ agentIdentifier, ...props }: AgentGPGKeyServiceListProps) => (
  <Get<
    GpgkeysGnuPGPublicKeyList,
    GatewayruntimeError,
    AgentGPGKeyServiceListQueryParams,
    AgentGPGKeyServiceListPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/gpgkeys`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentGPGKeyServiceListProps = Omit<
  UseGetProps<
    GpgkeysGnuPGPublicKeyList,
    GatewayruntimeError,
    AgentGPGKeyServiceListQueryParams,
    AgentGPGKeyServiceListPathParams
  >,
  'path'
> &
  AgentGPGKeyServiceListPathParams

/**
 * List all available repository certificates
 *
 * List all available repository certificates.
 */
export const useAgentGPGKeyServiceList = ({ agentIdentifier, ...props }: UseAgentGPGKeyServiceListProps) =>
  useGet<
    GpgkeysGnuPGPublicKeyList,
    GatewayruntimeError,
    AgentGPGKeyServiceListQueryParams,
    AgentGPGKeyServiceListPathParams
  >((paramsInPath: AgentGPGKeyServiceListPathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/gpgkeys`, {
    base: window.getApiBaseUrl('gitops'),
    pathParams: { agentIdentifier },
    ...props
  })

export interface AgentGPGKeyServiceCreateQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentGPGKeyServiceCreatePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentGPGKeyServiceCreateProps = Omit<
  MutateProps<
    GpgkeysGnuPGPublicKeyCreateResponse,
    GatewayruntimeError,
    AgentGPGKeyServiceCreateQueryParams,
    GpgkeysGnuPGPublicKeyCreateRequest,
    AgentGPGKeyServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentGPGKeyServiceCreatePathParams

/**
 * Create one or more GPG public keys in the server's configuration
 *
 * Create one or more GPG public keys in the server's configuration.
 */
export const AgentGPGKeyServiceCreate = ({ agentIdentifier, ...props }: AgentGPGKeyServiceCreateProps) => (
  <Mutate<
    GpgkeysGnuPGPublicKeyCreateResponse,
    GatewayruntimeError,
    AgentGPGKeyServiceCreateQueryParams,
    GpgkeysGnuPGPublicKeyCreateRequest,
    AgentGPGKeyServiceCreatePathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/gpgkeys`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentGPGKeyServiceCreateProps = Omit<
  UseMutateProps<
    GpgkeysGnuPGPublicKeyCreateResponse,
    GatewayruntimeError,
    AgentGPGKeyServiceCreateQueryParams,
    GpgkeysGnuPGPublicKeyCreateRequest,
    AgentGPGKeyServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentGPGKeyServiceCreatePathParams

/**
 * Create one or more GPG public keys in the server's configuration
 *
 * Create one or more GPG public keys in the server's configuration.
 */
export const useAgentGPGKeyServiceCreate = ({ agentIdentifier, ...props }: UseAgentGPGKeyServiceCreateProps) =>
  useMutate<
    GpgkeysGnuPGPublicKeyCreateResponse,
    GatewayruntimeError,
    AgentGPGKeyServiceCreateQueryParams,
    GpgkeysGnuPGPublicKeyCreateRequest,
    AgentGPGKeyServiceCreatePathParams
  >(
    'POST',
    (paramsInPath: AgentGPGKeyServiceCreatePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/gpgkeys`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentGPGKeyServiceDeleteQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentGPGKeyServiceDeletePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentGPGKeyServiceDeleteProps = Omit<
  MutateProps<
    GpgkeysGnuPGPublicKeyResponse,
    GatewayruntimeError,
    AgentGPGKeyServiceDeleteQueryParams,
    string,
    AgentGPGKeyServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentGPGKeyServiceDeletePathParams

/**
 * Delete specified GPG public key from the server's configuration
 *
 * Delete specified GPG public key from the server's configuration.
 */
export const AgentGPGKeyServiceDelete = ({ agentIdentifier, ...props }: AgentGPGKeyServiceDeleteProps) => (
  <Mutate<
    GpgkeysGnuPGPublicKeyResponse,
    GatewayruntimeError,
    AgentGPGKeyServiceDeleteQueryParams,
    string,
    AgentGPGKeyServiceDeletePathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/gpgkeys`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentGPGKeyServiceDeleteProps = Omit<
  UseMutateProps<
    GpgkeysGnuPGPublicKeyResponse,
    GatewayruntimeError,
    AgentGPGKeyServiceDeleteQueryParams,
    string,
    AgentGPGKeyServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentGPGKeyServiceDeletePathParams

/**
 * Delete specified GPG public key from the server's configuration
 *
 * Delete specified GPG public key from the server's configuration.
 */
export const useAgentGPGKeyServiceDelete = ({ agentIdentifier, ...props }: UseAgentGPGKeyServiceDeleteProps) =>
  useMutate<
    GpgkeysGnuPGPublicKeyResponse,
    GatewayruntimeError,
    AgentGPGKeyServiceDeleteQueryParams,
    string,
    AgentGPGKeyServiceDeletePathParams
  >(
    'DELETE',
    (paramsInPath: AgentGPGKeyServiceDeletePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/gpgkeys`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentGPGKeyServiceGetQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentGPGKeyServiceGetPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  /**
   * The GPG key ID to query for
   */
  queryKeyId: string
}

export type AgentGPGKeyServiceGetProps = Omit<
  GetProps<
    GpgkeysGnuPGPublicKey,
    GatewayruntimeError,
    AgentGPGKeyServiceGetQueryParams,
    AgentGPGKeyServiceGetPathParams
  >,
  'path'
> &
  AgentGPGKeyServiceGetPathParams

/**
 * Get information about specified GPG public key from the server
 *
 * Get information about specified GPG public key from the server.
 */
export const AgentGPGKeyServiceGet = ({ agentIdentifier, queryKeyId, ...props }: AgentGPGKeyServiceGetProps) => (
  <Get<GpgkeysGnuPGPublicKey, GatewayruntimeError, AgentGPGKeyServiceGetQueryParams, AgentGPGKeyServiceGetPathParams>
    path={`/api/v1/agents/${agentIdentifier}/gpgkeys/${queryKeyId}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentGPGKeyServiceGetProps = Omit<
  UseGetProps<
    GpgkeysGnuPGPublicKey,
    GatewayruntimeError,
    AgentGPGKeyServiceGetQueryParams,
    AgentGPGKeyServiceGetPathParams
  >,
  'path'
> &
  AgentGPGKeyServiceGetPathParams

/**
 * Get information about specified GPG public key from the server
 *
 * Get information about specified GPG public key from the server.
 */
export const useAgentGPGKeyServiceGet = ({ agentIdentifier, queryKeyId, ...props }: UseAgentGPGKeyServiceGetProps) =>
  useGet<GpgkeysGnuPGPublicKey, GatewayruntimeError, AgentGPGKeyServiceGetQueryParams, AgentGPGKeyServiceGetPathParams>(
    (paramsInPath: AgentGPGKeyServiceGetPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/gpgkeys/${paramsInPath.queryKeyId}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryKeyId }, ...props }
  )

export interface AgentServiceForServerGetDeployHelmChartResponse {
  error?: RuntimeStreamError
  result?: V1DownloadResponse
}

export interface AgentServiceForServerGetDeployHelmChartQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  namespace?: string
  /**
   * Disaster Recovery Identifier for entity.
   */
  disasterRecoveryIdentifier?: string
  skipCrds?: boolean
}

export interface AgentServiceForServerGetDeployHelmChartPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentServiceForServerGetDeployHelmChartProps = Omit<
  GetProps<
    AgentServiceForServerGetDeployHelmChartResponse,
    GatewayruntimeError,
    AgentServiceForServerGetDeployHelmChartQueryParams,
    AgentServiceForServerGetDeployHelmChartPathParams
  >,
  'path'
> &
  AgentServiceForServerGetDeployHelmChartPathParams

/**
 * GetDeployHelmChart returns the Helm Chart for depoying the agents.
 */
export const AgentServiceForServerGetDeployHelmChart = ({
  agentIdentifier,
  ...props
}: AgentServiceForServerGetDeployHelmChartProps) => (
  <Get<
    AgentServiceForServerGetDeployHelmChartResponse,
    GatewayruntimeError,
    AgentServiceForServerGetDeployHelmChartQueryParams,
    AgentServiceForServerGetDeployHelmChartPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/helm-chart`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerGetDeployHelmChartProps = Omit<
  UseGetProps<
    AgentServiceForServerGetDeployHelmChartResponse,
    GatewayruntimeError,
    AgentServiceForServerGetDeployHelmChartQueryParams,
    AgentServiceForServerGetDeployHelmChartPathParams
  >,
  'path'
> &
  AgentServiceForServerGetDeployHelmChartPathParams

/**
 * GetDeployHelmChart returns the Helm Chart for depoying the agents.
 */
export const useAgentServiceForServerGetDeployHelmChart = ({
  agentIdentifier,
  ...props
}: UseAgentServiceForServerGetDeployHelmChartProps) =>
  useGet<
    AgentServiceForServerGetDeployHelmChartResponse,
    GatewayruntimeError,
    AgentServiceForServerGetDeployHelmChartQueryParams,
    AgentServiceForServerGetDeployHelmChartPathParams
  >(
    (paramsInPath: AgentServiceForServerGetDeployHelmChartPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/helm-chart`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentClusterServiceCreateHostedPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentClusterServiceCreateHostedProps = Omit<
  MutateProps<Servicev1Cluster, GatewayruntimeError, void, void, AgentClusterServiceCreateHostedPathParams>,
  'path' | 'verb'
> &
  AgentClusterServiceCreateHostedPathParams

/**
 * CreateHosted creates a harness hosted cluster
 *
 * Creates Harness hosted cluster.
 */
export const AgentClusterServiceCreateHosted = ({
  agentIdentifier,
  ...props
}: AgentClusterServiceCreateHostedProps) => (
  <Mutate<Servicev1Cluster, GatewayruntimeError, void, void, AgentClusterServiceCreateHostedPathParams>
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/hosted/cluster`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentClusterServiceCreateHostedProps = Omit<
  UseMutateProps<Servicev1Cluster, GatewayruntimeError, void, void, AgentClusterServiceCreateHostedPathParams>,
  'path' | 'verb'
> &
  AgentClusterServiceCreateHostedPathParams

/**
 * CreateHosted creates a harness hosted cluster
 *
 * Creates Harness hosted cluster.
 */
export const useAgentClusterServiceCreateHosted = ({
  agentIdentifier,
  ...props
}: UseAgentClusterServiceCreateHostedProps) =>
  useMutate<Servicev1Cluster, GatewayruntimeError, void, void, AgentClusterServiceCreateHostedPathParams>(
    'POST',
    (paramsInPath: AgentClusterServiceCreateHostedPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/hosted/cluster`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentServiceForServerSetPrimaryNodePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentServiceForServerSetPrimaryNodeProps = Omit<
  MutateProps<
    V1Agent,
    GatewayruntimeError,
    void,
    V1AgentSetPrimaryNodeRequest,
    AgentServiceForServerSetPrimaryNodePathParams
  >,
  'path' | 'verb'
> &
  AgentServiceForServerSetPrimaryNodePathParams

/**
 * Set primary disaster recovery node.
 */
export const AgentServiceForServerSetPrimaryNode = ({
  agentIdentifier,
  ...props
}: AgentServiceForServerSetPrimaryNodeProps) => (
  <Mutate<
    V1Agent,
    GatewayruntimeError,
    void,
    V1AgentSetPrimaryNodeRequest,
    AgentServiceForServerSetPrimaryNodePathParams
  >
    verb="PATCH"
    path={`/api/v1/agents/${agentIdentifier}/primaryNode`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerSetPrimaryNodeProps = Omit<
  UseMutateProps<
    V1Agent,
    GatewayruntimeError,
    void,
    V1AgentSetPrimaryNodeRequest,
    AgentServiceForServerSetPrimaryNodePathParams
  >,
  'path' | 'verb'
> &
  AgentServiceForServerSetPrimaryNodePathParams

/**
 * Set primary disaster recovery node.
 */
export const useAgentServiceForServerSetPrimaryNode = ({
  agentIdentifier,
  ...props
}: UseAgentServiceForServerSetPrimaryNodeProps) =>
  useMutate<
    V1Agent,
    GatewayruntimeError,
    void,
    V1AgentSetPrimaryNodeRequest,
    AgentServiceForServerSetPrimaryNodePathParams
  >(
    'PATCH',
    (paramsInPath: AgentServiceForServerSetPrimaryNodePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/primaryNode`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentProjectServiceListQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.name'?: string
}

export interface AgentProjectServiceListPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentProjectServiceListProps = Omit<
  GetProps<
    AppprojectsAppProjectList,
    GatewayruntimeError,
    AgentProjectServiceListQueryParams,
    AgentProjectServiceListPathParams
  >,
  'path'
> &
  AgentProjectServiceListPathParams

/**
 * List returns list of projects
 *
 * Lists lists argo projects.
 */
export const AgentProjectServiceList = ({ agentIdentifier, ...props }: AgentProjectServiceListProps) => (
  <Get<
    AppprojectsAppProjectList,
    GatewayruntimeError,
    AgentProjectServiceListQueryParams,
    AgentProjectServiceListPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/projects`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentProjectServiceListProps = Omit<
  UseGetProps<
    AppprojectsAppProjectList,
    GatewayruntimeError,
    AgentProjectServiceListQueryParams,
    AgentProjectServiceListPathParams
  >,
  'path'
> &
  AgentProjectServiceListPathParams

/**
 * List returns list of projects
 *
 * Lists lists argo projects.
 */
export const useAgentProjectServiceList = ({ agentIdentifier, ...props }: UseAgentProjectServiceListProps) =>
  useGet<
    AppprojectsAppProjectList,
    GatewayruntimeError,
    AgentProjectServiceListQueryParams,
    AgentProjectServiceListPathParams
  >((paramsInPath: AgentProjectServiceListPathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/projects`, {
    base: window.getApiBaseUrl('gitops'),
    pathParams: { agentIdentifier },
    ...props
  })

export interface AgentProjectServiceCreateQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentProjectServiceCreatePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentProjectServiceCreateProps = Omit<
  MutateProps<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceCreateQueryParams,
    ProjectsProjectCreateRequest,
    AgentProjectServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentProjectServiceCreatePathParams

/**
 * Create a new project
 *
 * Create a new project
 */
export const AgentProjectServiceCreate = ({ agentIdentifier, ...props }: AgentProjectServiceCreateProps) => (
  <Mutate<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceCreateQueryParams,
    ProjectsProjectCreateRequest,
    AgentProjectServiceCreatePathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/projects`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentProjectServiceCreateProps = Omit<
  UseMutateProps<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceCreateQueryParams,
    ProjectsProjectCreateRequest,
    AgentProjectServiceCreatePathParams
  >,
  'path' | 'verb'
> &
  AgentProjectServiceCreatePathParams

/**
 * Create a new project
 *
 * Create a new project
 */
export const useAgentProjectServiceCreate = ({ agentIdentifier, ...props }: UseAgentProjectServiceCreateProps) =>
  useMutate<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceCreateQueryParams,
    ProjectsProjectCreateRequest,
    AgentProjectServiceCreatePathParams
  >(
    'POST',
    (paramsInPath: AgentProjectServiceCreatePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/projects`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentProjectServiceDeleteQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentProjectServiceDeletePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentProjectServiceDeleteProps = Omit<
  MutateProps<
    ProjectsEmptyResponse,
    GatewayruntimeError,
    AgentProjectServiceDeleteQueryParams,
    string,
    AgentProjectServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentProjectServiceDeletePathParams

/**
 * Delete deletes a project
 *
 * Delete deletes a project.
 */
export const AgentProjectServiceDelete = ({ agentIdentifier, ...props }: AgentProjectServiceDeleteProps) => (
  <Mutate<
    ProjectsEmptyResponse,
    GatewayruntimeError,
    AgentProjectServiceDeleteQueryParams,
    string,
    AgentProjectServiceDeletePathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/projects`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentProjectServiceDeleteProps = Omit<
  UseMutateProps<
    ProjectsEmptyResponse,
    GatewayruntimeError,
    AgentProjectServiceDeleteQueryParams,
    string,
    AgentProjectServiceDeletePathParams
  >,
  'path' | 'verb'
> &
  AgentProjectServiceDeletePathParams

/**
 * Delete deletes a project
 *
 * Delete deletes a project.
 */
export const useAgentProjectServiceDelete = ({ agentIdentifier, ...props }: UseAgentProjectServiceDeleteProps) =>
  useMutate<
    ProjectsEmptyResponse,
    GatewayruntimeError,
    AgentProjectServiceDeleteQueryParams,
    string,
    AgentProjectServiceDeletePathParams
  >(
    'DELETE',
    (paramsInPath: AgentProjectServiceDeletePathParams) => `/api/v1/agents/${paramsInPath.agentIdentifier}/projects`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentProjectServiceGetQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentProjectServiceGetPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  queryName: string
}

export type AgentProjectServiceGetProps = Omit<
  GetProps<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceGetQueryParams,
    AgentProjectServiceGetPathParams
  >,
  'path'
> &
  AgentProjectServiceGetPathParams

/**
 * Get returns a project by name
 *
 * Get returns an argo project by name.
 */
export const AgentProjectServiceGet = ({ agentIdentifier, queryName, ...props }: AgentProjectServiceGetProps) => (
  <Get<AppprojectsAppProject, GatewayruntimeError, AgentProjectServiceGetQueryParams, AgentProjectServiceGetPathParams>
    path={`/api/v1/agents/${agentIdentifier}/projects/${queryName}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentProjectServiceGetProps = Omit<
  UseGetProps<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceGetQueryParams,
    AgentProjectServiceGetPathParams
  >,
  'path'
> &
  AgentProjectServiceGetPathParams

/**
 * Get returns a project by name
 *
 * Get returns an argo project by name.
 */
export const useAgentProjectServiceGet = ({ agentIdentifier, queryName, ...props }: UseAgentProjectServiceGetProps) =>
  useGet<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceGetQueryParams,
    AgentProjectServiceGetPathParams
  >(
    (paramsInPath: AgentProjectServiceGetPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/projects/${paramsInPath.queryName}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryName }, ...props }
  )

export interface AgentProjectServiceUpdateQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentProjectServiceUpdatePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   * +optional
   */
  requestProjectMetadataName: string
}

export type AgentProjectServiceUpdateProps = Omit<
  MutateProps<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceUpdateQueryParams,
    ProjectsProjectUpdateRequest,
    AgentProjectServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  AgentProjectServiceUpdatePathParams

/**
 * Update updates a project
 *
 * Update updates a project.
 */
export const AgentProjectServiceUpdate = ({
  agentIdentifier,
  requestProjectMetadataName,
  ...props
}: AgentProjectServiceUpdateProps) => (
  <Mutate<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceUpdateQueryParams,
    ProjectsProjectUpdateRequest,
    AgentProjectServiceUpdatePathParams
  >
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/projects/${requestProjectMetadataName}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentProjectServiceUpdateProps = Omit<
  UseMutateProps<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceUpdateQueryParams,
    ProjectsProjectUpdateRequest,
    AgentProjectServiceUpdatePathParams
  >,
  'path' | 'verb'
> &
  AgentProjectServiceUpdatePathParams

/**
 * Update updates a project
 *
 * Update updates a project.
 */
export const useAgentProjectServiceUpdate = ({
  agentIdentifier,
  requestProjectMetadataName,
  ...props
}: UseAgentProjectServiceUpdateProps) =>
  useMutate<
    AppprojectsAppProject,
    GatewayruntimeError,
    AgentProjectServiceUpdateQueryParams,
    ProjectsProjectUpdateRequest,
    AgentProjectServiceUpdatePathParams
  >(
    'PUT',
    (paramsInPath: AgentProjectServiceUpdatePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/projects/${paramsInPath.requestProjectMetadataName}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, requestProjectMetadataName }, ...props }
  )

export interface ReconcilerServiceCollectCountsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface ReconcilerServiceCollectCountsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type ReconcilerServiceCollectCountsProps = Omit<
  MutateProps<
    ReconcilerReconcileCountsResponse,
    GatewayruntimeError,
    ReconcilerServiceCollectCountsQueryParams,
    Servicev1ReconcilerFilterRequestBody,
    ReconcilerServiceCollectCountsPathParams
  >,
  'path' | 'verb'
> &
  ReconcilerServiceCollectCountsPathParams

/**
 * Returns number of entities that exist in the cluster on the agent.
 * Filter can be used to count only global entities (with empty project) and those specified by the filter.
 *
 * Returns number of entities that exist in the cluster on the agent.
 * Filter can be used to count only global entities (with empty project) and those specified by the filter.
 */
export const ReconcilerServiceCollectCounts = ({ agentIdentifier, ...props }: ReconcilerServiceCollectCountsProps) => (
  <Mutate<
    ReconcilerReconcileCountsResponse,
    GatewayruntimeError,
    ReconcilerServiceCollectCountsQueryParams,
    Servicev1ReconcilerFilterRequestBody,
    ReconcilerServiceCollectCountsPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/reconcile/counts`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseReconcilerServiceCollectCountsProps = Omit<
  UseMutateProps<
    ReconcilerReconcileCountsResponse,
    GatewayruntimeError,
    ReconcilerServiceCollectCountsQueryParams,
    Servicev1ReconcilerFilterRequestBody,
    ReconcilerServiceCollectCountsPathParams
  >,
  'path' | 'verb'
> &
  ReconcilerServiceCollectCountsPathParams

/**
 * Returns number of entities that exist in the cluster on the agent.
 * Filter can be used to count only global entities (with empty project) and those specified by the filter.
 *
 * Returns number of entities that exist in the cluster on the agent.
 * Filter can be used to count only global entities (with empty project) and those specified by the filter.
 */
export const useReconcilerServiceCollectCounts = ({
  agentIdentifier,
  ...props
}: UseReconcilerServiceCollectCountsProps) =>
  useMutate<
    ReconcilerReconcileCountsResponse,
    GatewayruntimeError,
    ReconcilerServiceCollectCountsQueryParams,
    Servicev1ReconcilerFilterRequestBody,
    ReconcilerServiceCollectCountsPathParams
  >(
    'POST',
    (paramsInPath: ReconcilerServiceCollectCountsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/reconcile/counts`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface ReconcilerServiceImportDataQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface ReconcilerServiceImportDataPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type ReconcilerServiceImportDataProps = Omit<
  MutateProps<
    ReconcilerReconcileCountsResponse,
    GatewayruntimeError,
    ReconcilerServiceImportDataQueryParams,
    Servicev1ReconcilerFilterRequestBody,
    ReconcilerServiceImportDataPathParams
  >,
  'path' | 'verb'
> &
  ReconcilerServiceImportDataPathParams

/**
 * Imports data from cluster via agent. There must be at least one project mapping in the database.
 * Returns number of entities imported.
 *
 * Imports data from cluster via agent. There must be at least one project mapping in the database.
 * Returns number of entities imported.
 */
export const ReconcilerServiceImportData = ({ agentIdentifier, ...props }: ReconcilerServiceImportDataProps) => (
  <Mutate<
    ReconcilerReconcileCountsResponse,
    GatewayruntimeError,
    ReconcilerServiceImportDataQueryParams,
    Servicev1ReconcilerFilterRequestBody,
    ReconcilerServiceImportDataPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/reconcile/import`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseReconcilerServiceImportDataProps = Omit<
  UseMutateProps<
    ReconcilerReconcileCountsResponse,
    GatewayruntimeError,
    ReconcilerServiceImportDataQueryParams,
    Servicev1ReconcilerFilterRequestBody,
    ReconcilerServiceImportDataPathParams
  >,
  'path' | 'verb'
> &
  ReconcilerServiceImportDataPathParams

/**
 * Imports data from cluster via agent. There must be at least one project mapping in the database.
 * Returns number of entities imported.
 *
 * Imports data from cluster via agent. There must be at least one project mapping in the database.
 * Returns number of entities imported.
 */
export const useReconcilerServiceImportData = ({ agentIdentifier, ...props }: UseReconcilerServiceImportDataProps) =>
  useMutate<
    ReconcilerReconcileCountsResponse,
    GatewayruntimeError,
    ReconcilerServiceImportDataQueryParams,
    Servicev1ReconcilerFilterRequestBody,
    ReconcilerServiceImportDataPathParams
  >(
    'POST',
    (paramsInPath: ReconcilerServiceImportDataPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/reconcile/import`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryCredentialsServiceCreateRepositoryCredentialsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  identifier?: string
}

export interface AgentRepositoryCredentialsServiceCreateRepositoryCredentialsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryCredentialsServiceCreateRepositoryCredentialsProps = Omit<
  MutateProps<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceCreateRepositoryCredentialsQueryParams,
    HrepocredsRepoCredsCreateRequest,
    AgentRepositoryCredentialsServiceCreateRepositoryCredentialsPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryCredentialsServiceCreateRepositoryCredentialsPathParams

/**
 * Create creates a new repository credential
 *
 * Create creates a new repository credential.
 */
export const AgentRepositoryCredentialsServiceCreateRepositoryCredentials = ({
  agentIdentifier,
  ...props
}: AgentRepositoryCredentialsServiceCreateRepositoryCredentialsProps) => (
  <Mutate<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceCreateRepositoryCredentialsQueryParams,
    HrepocredsRepoCredsCreateRequest,
    AgentRepositoryCredentialsServiceCreateRepositoryCredentialsPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/repocreds`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryCredentialsServiceCreateRepositoryCredentialsProps = Omit<
  UseMutateProps<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceCreateRepositoryCredentialsQueryParams,
    HrepocredsRepoCredsCreateRequest,
    AgentRepositoryCredentialsServiceCreateRepositoryCredentialsPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryCredentialsServiceCreateRepositoryCredentialsPathParams

/**
 * Create creates a new repository credential
 *
 * Create creates a new repository credential.
 */
export const useAgentRepositoryCredentialsServiceCreateRepositoryCredentials = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryCredentialsServiceCreateRepositoryCredentialsProps) =>
  useMutate<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceCreateRepositoryCredentialsQueryParams,
    HrepocredsRepoCredsCreateRequest,
    AgentRepositoryCredentialsServiceCreateRepositoryCredentialsPathParams
  >(
    'POST',
    (paramsInPath: AgentRepositoryCredentialsServiceCreateRepositoryCredentialsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repocreds`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  identifier?: string
}

export interface AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlProps = Omit<
  MutateProps<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlQueryParams,
    HrepocredsRepoCredsQuery,
    AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlPathParams

/**
 * Get returns a repository credential given its url
 *
 * Get returns a repository credential given its url.
 */
export const AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrl = ({
  agentIdentifier,
  ...props
}: AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlProps) => (
  <Mutate<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlQueryParams,
    HrepocredsRepoCredsQuery,
    AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/repocreds/get`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlProps = Omit<
  UseMutateProps<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlQueryParams,
    HrepocredsRepoCredsQuery,
    AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlPathParams

/**
 * Get returns a repository credential given its url
 *
 * Get returns a repository credential given its url.
 */
export const useAgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrl = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlProps) =>
  useMutate<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlQueryParams,
    HrepocredsRepoCredsQuery,
    AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlPathParams
  >(
    'POST',
    (paramsInPath: AgentRepositoryCredentialsServiceGetCredentialsForRepositoryUrlPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repocreds/get`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsProps = Omit<
  MutateProps<
    HrepocredsRepoCredsResponse,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsQueryParams,
    string,
    AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsPathParams

/**
 * Delete deletes a repository credential
 *
 *  Delete deletes a repository credential.
 */
export const AgentRepositoryCredentialsServiceDeleteRepositoryCredentials = ({
  agentIdentifier,
  ...props
}: AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsProps) => (
  <Mutate<
    HrepocredsRepoCredsResponse,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsQueryParams,
    string,
    AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsPathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/repocreds`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryCredentialsServiceDeleteRepositoryCredentialsProps = Omit<
  UseMutateProps<
    HrepocredsRepoCredsResponse,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsQueryParams,
    string,
    AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsPathParams

/**
 * Delete deletes a repository credential
 *
 *  Delete deletes a repository credential.
 */
export const useAgentRepositoryCredentialsServiceDeleteRepositoryCredentials = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryCredentialsServiceDeleteRepositoryCredentialsProps) =>
  useMutate<
    HrepocredsRepoCredsResponse,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsQueryParams,
    string,
    AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsPathParams
  >(
    'DELETE',
    (paramsInPath: AgentRepositoryCredentialsServiceDeleteRepositoryCredentialsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repocreds`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryCredentialsServiceGetRepositoryCredentialsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Repo URL for query.
   */
  'query.url'?: string
  /**
   * RepoCreds type - git or helm.
   */
  'query.repoCredsType'?: string
}

export interface AgentRepositoryCredentialsServiceGetRepositoryCredentialsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentRepositoryCredentialsServiceGetRepositoryCredentialsProps = Omit<
  GetProps<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceGetRepositoryCredentialsQueryParams,
    AgentRepositoryCredentialsServiceGetRepositoryCredentialsPathParams
  >,
  'path'
> &
  AgentRepositoryCredentialsServiceGetRepositoryCredentialsPathParams

/**
 * Get returns a repository credential given its identifier
 *
 * Get returns a repository credential given its identifier.
 */
export const AgentRepositoryCredentialsServiceGetRepositoryCredentials = ({
  agentIdentifier,
  identifier,
  ...props
}: AgentRepositoryCredentialsServiceGetRepositoryCredentialsProps) => (
  <Get<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceGetRepositoryCredentialsQueryParams,
    AgentRepositoryCredentialsServiceGetRepositoryCredentialsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repocreds/${identifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryCredentialsServiceGetRepositoryCredentialsProps = Omit<
  UseGetProps<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceGetRepositoryCredentialsQueryParams,
    AgentRepositoryCredentialsServiceGetRepositoryCredentialsPathParams
  >,
  'path'
> &
  AgentRepositoryCredentialsServiceGetRepositoryCredentialsPathParams

/**
 * Get returns a repository credential given its identifier
 *
 * Get returns a repository credential given its identifier.
 */
export const useAgentRepositoryCredentialsServiceGetRepositoryCredentials = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAgentRepositoryCredentialsServiceGetRepositoryCredentialsProps) =>
  useGet<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceGetRepositoryCredentialsQueryParams,
    AgentRepositoryCredentialsServiceGetRepositoryCredentialsPathParams
  >(
    (paramsInPath: AgentRepositoryCredentialsServiceGetRepositoryCredentialsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repocreds/${paramsInPath.identifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsProps = Omit<
  MutateProps<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsQueryParams,
    HrepocredsRepoCredsUpdateRequest,
    AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsPathParams

/**
 * Update updates a repository credential
 *
 * Update updates a repository credential.
 */
export const AgentRepositoryCredentialsServiceUpdateRepositoryCredentials = ({
  agentIdentifier,
  identifier,
  ...props
}: AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsProps) => (
  <Mutate<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsQueryParams,
    HrepocredsRepoCredsUpdateRequest,
    AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsPathParams
  >
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/repocreds/${identifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryCredentialsServiceUpdateRepositoryCredentialsProps = Omit<
  UseMutateProps<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsQueryParams,
    HrepocredsRepoCredsUpdateRequest,
    AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsPathParams

/**
 * Update updates a repository credential
 *
 * Update updates a repository credential.
 */
export const useAgentRepositoryCredentialsServiceUpdateRepositoryCredentials = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAgentRepositoryCredentialsServiceUpdateRepositoryCredentialsProps) =>
  useMutate<
    Servicev1RepositoryCredentials,
    GatewayruntimeError,
    AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsQueryParams,
    HrepocredsRepoCredsUpdateRequest,
    AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsPathParams
  >(
    'PUT',
    (paramsInPath: AgentRepositoryCredentialsServiceUpdateRepositoryCredentialsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repocreds/${paramsInPath.identifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentRepositoryServiceListRepositoriesQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  identifier?: string
  /**
   * Repo URL for query.
   */
  'query.repo'?: string
  /**
   * Whether to force a cache refresh on repo's connection state.
   */
  'query.forceRefresh'?: boolean
  /**
   * The associated project project.
   */
  'query.project'?: string
}

export interface AgentRepositoryServiceListRepositoriesPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryServiceListRepositoriesProps = Omit<
  GetProps<
    RepositoriesRepositoryList,
    GatewayruntimeError,
    AgentRepositoryServiceListRepositoriesQueryParams,
    AgentRepositoryServiceListRepositoriesPathParams
  >,
  'path'
> &
  AgentRepositoryServiceListRepositoriesPathParams

/**
 * ListRepositories gets a list of all configured repositories
 *
 * ListRepositories gets a list of all configured repositories.
 */
export const AgentRepositoryServiceListRepositories = ({
  agentIdentifier,
  ...props
}: AgentRepositoryServiceListRepositoriesProps) => (
  <Get<
    RepositoriesRepositoryList,
    GatewayruntimeError,
    AgentRepositoryServiceListRepositoriesQueryParams,
    AgentRepositoryServiceListRepositoriesPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repositories`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceListRepositoriesProps = Omit<
  UseGetProps<
    RepositoriesRepositoryList,
    GatewayruntimeError,
    AgentRepositoryServiceListRepositoriesQueryParams,
    AgentRepositoryServiceListRepositoriesPathParams
  >,
  'path'
> &
  AgentRepositoryServiceListRepositoriesPathParams

/**
 * ListRepositories gets a list of all configured repositories
 *
 * ListRepositories gets a list of all configured repositories.
 */
export const useAgentRepositoryServiceListRepositories = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryServiceListRepositoriesProps) =>
  useGet<
    RepositoriesRepositoryList,
    GatewayruntimeError,
    AgentRepositoryServiceListRepositoriesQueryParams,
    AgentRepositoryServiceListRepositoriesPathParams
  >(
    (paramsInPath: AgentRepositoryServiceListRepositoriesPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryServiceCreateRepositoryQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  identifier?: string
  repoCredsId?: string
}

export interface AgentRepositoryServiceCreateRepositoryPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryServiceCreateRepositoryProps = Omit<
  MutateProps<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceCreateRepositoryQueryParams,
    RepositoriesRepoCreateRequest,
    AgentRepositoryServiceCreateRepositoryPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceCreateRepositoryPathParams

/**
 * CreateRepository creates a new repository configuration
 *
 * CreateRepository creates a new repository configuration.
 */
export const AgentRepositoryServiceCreateRepository = ({
  agentIdentifier,
  ...props
}: AgentRepositoryServiceCreateRepositoryProps) => (
  <Mutate<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceCreateRepositoryQueryParams,
    RepositoriesRepoCreateRequest,
    AgentRepositoryServiceCreateRepositoryPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/repositories`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceCreateRepositoryProps = Omit<
  UseMutateProps<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceCreateRepositoryQueryParams,
    RepositoriesRepoCreateRequest,
    AgentRepositoryServiceCreateRepositoryPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceCreateRepositoryPathParams

/**
 * CreateRepository creates a new repository configuration
 *
 * CreateRepository creates a new repository configuration.
 */
export const useAgentRepositoryServiceCreateRepository = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryServiceCreateRepositoryProps) =>
  useMutate<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceCreateRepositoryQueryParams,
    RepositoriesRepoCreateRequest,
    AgentRepositoryServiceCreateRepositoryPathParams
  >(
    'POST',
    (paramsInPath: AgentRepositoryServiceCreateRepositoryPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryServiceCheckExternalSecretsOperatorQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentRepositoryServiceCheckExternalSecretsOperatorPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryServiceCheckExternalSecretsOperatorProps = Omit<
  GetProps<
    RepositoriesCheckESOResponse,
    GatewayruntimeError,
    AgentRepositoryServiceCheckExternalSecretsOperatorQueryParams,
    AgentRepositoryServiceCheckExternalSecretsOperatorPathParams
  >,
  'path'
> &
  AgentRepositoryServiceCheckExternalSecretsOperatorPathParams

/**
 * Checks whether External Secrets Operator is installed
 *
 * Checks whether External Secrets Operator is installed or not
 */
export const AgentRepositoryServiceCheckExternalSecretsOperator = ({
  agentIdentifier,
  ...props
}: AgentRepositoryServiceCheckExternalSecretsOperatorProps) => (
  <Get<
    RepositoriesCheckESOResponse,
    GatewayruntimeError,
    AgentRepositoryServiceCheckExternalSecretsOperatorQueryParams,
    AgentRepositoryServiceCheckExternalSecretsOperatorPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repositories/eso/check`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceCheckExternalSecretsOperatorProps = Omit<
  UseGetProps<
    RepositoriesCheckESOResponse,
    GatewayruntimeError,
    AgentRepositoryServiceCheckExternalSecretsOperatorQueryParams,
    AgentRepositoryServiceCheckExternalSecretsOperatorPathParams
  >,
  'path'
> &
  AgentRepositoryServiceCheckExternalSecretsOperatorPathParams

/**
 * Checks whether External Secrets Operator is installed
 *
 * Checks whether External Secrets Operator is installed or not
 */
export const useAgentRepositoryServiceCheckExternalSecretsOperator = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryServiceCheckExternalSecretsOperatorProps) =>
  useGet<
    RepositoriesCheckESOResponse,
    GatewayruntimeError,
    AgentRepositoryServiceCheckExternalSecretsOperatorQueryParams,
    AgentRepositoryServiceCheckExternalSecretsOperatorPathParams
  >(
    (paramsInPath: AgentRepositoryServiceCheckExternalSecretsOperatorPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/eso/check`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryServiceListESOGeneratorsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  type?: 'UNSET' | 'AWS_ECR' | 'GOOGLE_GCR'
  name?: string
  url?: string
}

export interface AgentRepositoryServiceListESOGeneratorsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryServiceListESOGeneratorsProps = Omit<
  GetProps<
    RepositoriesESOGeneratorResponse,
    GatewayruntimeError,
    AgentRepositoryServiceListESOGeneratorsQueryParams,
    AgentRepositoryServiceListESOGeneratorsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceListESOGeneratorsPathParams

/**
 * Returns a list of ESO generators installed in agent namespace.
 *
 * Returns a list of ESO generators installed in agent namespace.
 */
export const AgentRepositoryServiceListESOGenerators = ({
  agentIdentifier,
  ...props
}: AgentRepositoryServiceListESOGeneratorsProps) => (
  <Get<
    RepositoriesESOGeneratorResponse,
    GatewayruntimeError,
    AgentRepositoryServiceListESOGeneratorsQueryParams,
    AgentRepositoryServiceListESOGeneratorsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repositories/eso/generators`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceListESOGeneratorsProps = Omit<
  UseGetProps<
    RepositoriesESOGeneratorResponse,
    GatewayruntimeError,
    AgentRepositoryServiceListESOGeneratorsQueryParams,
    AgentRepositoryServiceListESOGeneratorsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceListESOGeneratorsPathParams

/**
 * Returns a list of ESO generators installed in agent namespace.
 *
 * Returns a list of ESO generators installed in agent namespace.
 */
export const useAgentRepositoryServiceListESOGenerators = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryServiceListESOGeneratorsProps) =>
  useGet<
    RepositoriesESOGeneratorResponse,
    GatewayruntimeError,
    AgentRepositoryServiceListESOGeneratorsQueryParams,
    AgentRepositoryServiceListESOGeneratorsPathParams
  >(
    (paramsInPath: AgentRepositoryServiceListESOGeneratorsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/eso/generators`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryServiceCheckOCIRepoTypeQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentRepositoryServiceCheckOCIRepoTypePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryServiceCheckOCIRepoTypeProps = Omit<
  MutateProps<
    V1OCIRepoTypeResponse,
    GatewayruntimeError,
    AgentRepositoryServiceCheckOCIRepoTypeQueryParams,
    V1OCIRepoType,
    AgentRepositoryServiceCheckOCIRepoTypePathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceCheckOCIRepoTypePathParams

/**
 * Returns the Repository type of OCI repo
 *
 * Returns the Repository type of OCI repo
 */
export const AgentRepositoryServiceCheckOCIRepoType = ({
  agentIdentifier,
  ...props
}: AgentRepositoryServiceCheckOCIRepoTypeProps) => (
  <Mutate<
    V1OCIRepoTypeResponse,
    GatewayruntimeError,
    AgentRepositoryServiceCheckOCIRepoTypeQueryParams,
    V1OCIRepoType,
    AgentRepositoryServiceCheckOCIRepoTypePathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/repositories/oci/type`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceCheckOCIRepoTypeProps = Omit<
  UseMutateProps<
    V1OCIRepoTypeResponse,
    GatewayruntimeError,
    AgentRepositoryServiceCheckOCIRepoTypeQueryParams,
    V1OCIRepoType,
    AgentRepositoryServiceCheckOCIRepoTypePathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceCheckOCIRepoTypePathParams

/**
 * Returns the Repository type of OCI repo
 *
 * Returns the Repository type of OCI repo
 */
export const useAgentRepositoryServiceCheckOCIRepoType = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryServiceCheckOCIRepoTypeProps) =>
  useMutate<
    V1OCIRepoTypeResponse,
    GatewayruntimeError,
    AgentRepositoryServiceCheckOCIRepoTypeQueryParams,
    V1OCIRepoType,
    AgentRepositoryServiceCheckOCIRepoTypePathParams
  >(
    'POST',
    (paramsInPath: AgentRepositoryServiceCheckOCIRepoTypePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/oci/type`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryServiceValidateAccessQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  identifier?: string
}

export interface AgentRepositoryServiceValidateAccessPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryServiceValidateAccessProps = Omit<
  MutateProps<
    CommonsConnectionState,
    GatewayruntimeError,
    AgentRepositoryServiceValidateAccessQueryParams,
    RepositoriesRepoAccessQuery,
    AgentRepositoryServiceValidateAccessPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceValidateAccessPathParams

/**
 * ValidateAccess gets connection state for a repository
 *
 * ValidateAccess gets connection state for a repository.
 */
export const AgentRepositoryServiceValidateAccess = ({
  agentIdentifier,
  ...props
}: AgentRepositoryServiceValidateAccessProps) => (
  <Mutate<
    CommonsConnectionState,
    GatewayruntimeError,
    AgentRepositoryServiceValidateAccessQueryParams,
    RepositoriesRepoAccessQuery,
    AgentRepositoryServiceValidateAccessPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentifier}/repositories/validate`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceValidateAccessProps = Omit<
  UseMutateProps<
    CommonsConnectionState,
    GatewayruntimeError,
    AgentRepositoryServiceValidateAccessQueryParams,
    RepositoriesRepoAccessQuery,
    AgentRepositoryServiceValidateAccessPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceValidateAccessPathParams

/**
 * ValidateAccess gets connection state for a repository
 *
 * ValidateAccess gets connection state for a repository.
 */
export const useAgentRepositoryServiceValidateAccess = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryServiceValidateAccessProps) =>
  useMutate<
    CommonsConnectionState,
    GatewayruntimeError,
    AgentRepositoryServiceValidateAccessQueryParams,
    RepositoriesRepoAccessQuery,
    AgentRepositoryServiceValidateAccessPathParams
  >(
    'POST',
    (paramsInPath: AgentRepositoryServiceValidateAccessPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/validate`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryServiceDeleteRepositoryQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Repo URL for query.
   */
  'query.repo'?: string
  /**
   * Whether to force a cache refresh on repo's connection state.
   */
  'query.forceRefresh'?: boolean
  /**
   * The associated project project.
   */
  'query.project'?: string
}

export interface AgentRepositoryServiceDeleteRepositoryPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentRepositoryServiceDeleteRepositoryProps = Omit<
  MutateProps<
    RepositoriesRepoResponse,
    GatewayruntimeError,
    AgentRepositoryServiceDeleteRepositoryQueryParams,
    string,
    AgentRepositoryServiceDeleteRepositoryPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceDeleteRepositoryPathParams

/**
 * DeleteRepository deletes a repository from the configuration
 *
 * DeleteRepository deletes a repository from the configuration.
 */
export const AgentRepositoryServiceDeleteRepository = ({
  agentIdentifier,
  ...props
}: AgentRepositoryServiceDeleteRepositoryProps) => (
  <Mutate<
    RepositoriesRepoResponse,
    GatewayruntimeError,
    AgentRepositoryServiceDeleteRepositoryQueryParams,
    string,
    AgentRepositoryServiceDeleteRepositoryPathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentifier}/repositories`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceDeleteRepositoryProps = Omit<
  UseMutateProps<
    RepositoriesRepoResponse,
    GatewayruntimeError,
    AgentRepositoryServiceDeleteRepositoryQueryParams,
    string,
    AgentRepositoryServiceDeleteRepositoryPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceDeleteRepositoryPathParams

/**
 * DeleteRepository deletes a repository from the configuration
 *
 * DeleteRepository deletes a repository from the configuration.
 */
export const useAgentRepositoryServiceDeleteRepository = ({
  agentIdentifier,
  ...props
}: UseAgentRepositoryServiceDeleteRepositoryProps) =>
  useMutate<
    RepositoriesRepoResponse,
    GatewayruntimeError,
    AgentRepositoryServiceDeleteRepositoryQueryParams,
    string,
    AgentRepositoryServiceDeleteRepositoryPathParams
  >(
    'DELETE',
    (paramsInPath: AgentRepositoryServiceDeleteRepositoryPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentRepositoryServiceGetQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Repo URL for query.
   */
  'query.repo'?: string
  /**
   * Whether to force a cache refresh on repo's connection state.
   */
  'query.forceRefresh'?: boolean
  /**
   * The associated project project.
   */
  'query.project'?: string
}

export interface AgentRepositoryServiceGetPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentRepositoryServiceGetProps = Omit<
  GetProps<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceGetQueryParams,
    AgentRepositoryServiceGetPathParams
  >,
  'path'
> &
  AgentRepositoryServiceGetPathParams

/**
 * Get returns a repository or its credentials
 *
 * Get returns a repository or its credentials.
 */
export const AgentRepositoryServiceGet = ({
  agentIdentifier,
  identifier,
  ...props
}: AgentRepositoryServiceGetProps) => (
  <Get<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceGetQueryParams,
    AgentRepositoryServiceGetPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repositories/${identifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceGetProps = Omit<
  UseGetProps<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceGetQueryParams,
    AgentRepositoryServiceGetPathParams
  >,
  'path'
> &
  AgentRepositoryServiceGetPathParams

/**
 * Get returns a repository or its credentials
 *
 * Get returns a repository or its credentials.
 */
export const useAgentRepositoryServiceGet = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAgentRepositoryServiceGetProps) =>
  useGet<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceGetQueryParams,
    AgentRepositoryServiceGetPathParams
  >(
    (paramsInPath: AgentRepositoryServiceGetPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/${paramsInPath.identifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentRepositoryServiceUpdateRepositoryQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AgentRepositoryServiceUpdateRepositoryPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentRepositoryServiceUpdateRepositoryProps = Omit<
  MutateProps<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceUpdateRepositoryQueryParams,
    RepositoriesRepoUpdateRequest,
    AgentRepositoryServiceUpdateRepositoryPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceUpdateRepositoryPathParams

/**
 * UpdateRepository updates a repository configuration
 *
 * UpdateRepository updates a repository configuration.
 */
export const AgentRepositoryServiceUpdateRepository = ({
  agentIdentifier,
  identifier,
  ...props
}: AgentRepositoryServiceUpdateRepositoryProps) => (
  <Mutate<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceUpdateRepositoryQueryParams,
    RepositoriesRepoUpdateRequest,
    AgentRepositoryServiceUpdateRepositoryPathParams
  >
    verb="PUT"
    path={`/api/v1/agents/${agentIdentifier}/repositories/${identifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceUpdateRepositoryProps = Omit<
  UseMutateProps<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceUpdateRepositoryQueryParams,
    RepositoriesRepoUpdateRequest,
    AgentRepositoryServiceUpdateRepositoryPathParams
  >,
  'path' | 'verb'
> &
  AgentRepositoryServiceUpdateRepositoryPathParams

/**
 * UpdateRepository updates a repository configuration
 *
 * UpdateRepository updates a repository configuration.
 */
export const useAgentRepositoryServiceUpdateRepository = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAgentRepositoryServiceUpdateRepositoryProps) =>
  useMutate<
    Servicev1Repository,
    GatewayruntimeError,
    AgentRepositoryServiceUpdateRepositoryQueryParams,
    RepositoriesRepoUpdateRequest,
    AgentRepositoryServiceUpdateRepositoryPathParams
  >(
    'PUT',
    (paramsInPath: AgentRepositoryServiceUpdateRepositoryPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/${paramsInPath.identifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentRepositoryServiceGetAppDetailsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * RepoURL is the URL to the repository (Git or Helm) that contains the application manifests.
   */
  'query.source.repoURL'?: string
  /**
   * Path is a directory path within the Git repository, and is only valid for applications sourced from Git.
   */
  'query.source.path'?: string
  /**
   * TargetRevision defines the revision of the source to sync the application to.
   * In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD.
   * In case of Helm, this is a semver tag for the Chart's version.
   */
  'query.source.targetRevision'?: string
  /**
   * ValuesFiles is a list of Helm value files to use when generating a template.
   */
  'query.source.helm.valueFiles'?: string[]
  /**
   * ReleaseName is the Helm release name to use. If omitted it will use the application name.
   */
  'query.source.helm.releaseName'?: string
  /**
   * Values specifies Helm values to be passed to helm template, typically defined as a block.
   */
  'query.source.helm.values'?: string
  /**
   * Version is the Helm version to use for templating (either "2" or "3").
   */
  'query.source.helm.version'?: string
  /**
   * PassCredentials pass credentials to all domains (Helm's --pass-credentials).
   */
  'query.source.helm.passCredentials'?: boolean
  /**
   * NamePrefix is a prefix appended to resources for Kustomize apps.
   */
  'query.source.kustomize.namePrefix'?: string
  /**
   * NameSuffix is a suffix appended to resources for Kustomize apps.
   */
  'query.source.kustomize.nameSuffix'?: string
  /**
   * Images is a list of Kustomize image override specifications.
   */
  'query.source.kustomize.images'?: string[]
  /**
   * Version controls which version of Kustomize to use for rendering manifests.
   */
  'query.source.kustomize.version'?: string
  /**
   * ForceCommonLabels specifies whether to force applying common labels to resources for Kustomize apps.
   */
  'query.source.kustomize.forceCommonLabels'?: boolean
  /**
   * ForceCommonAnnotations specifies whether to force applying common annotations to resources for Kustomize apps.
   */
  'query.source.kustomize.forceCommonAnnotations'?: boolean
  /**
   * Environment is a ksonnet application environment name.
   */
  'query.source.ksonnet.environment'?: string
  /**
   * Recurse specifies whether to scan a directory recursively for manifests.
   */
  'query.source.directory.recurse'?: boolean
  /**
   * Additional library search dirs.
   */
  'query.source.directory.jsonnet.libs'?: string[]
  /**
   * Exclude contains a glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
   */
  'query.source.directory.exclude'?: string
  /**
   * Include contains a glob pattern to match paths against that should be explicitly included during manifest generation.
   */
  'query.source.directory.include'?: string
  'query.source.plugin.name'?: string
  /**
   * Chart is a Helm chart name, and must be specified for applications sourced from a Helm repo.
   */
  'query.source.chart'?: string
  'query.appName'?: string
  'query.appProject'?: string
}

export interface AgentRepositoryServiceGetAppDetailsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentRepositoryServiceGetAppDetailsProps = Omit<
  GetProps<
    RepositoriesRepoAppDetailsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceGetAppDetailsQueryParams,
    AgentRepositoryServiceGetAppDetailsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceGetAppDetailsPathParams

/**
 * GetAppDetails returns application details by given path
 *
 * GetAppDetails returns application details by given path.
 */
export const AgentRepositoryServiceGetAppDetails = ({
  agentIdentifier,
  identifier,
  ...props
}: AgentRepositoryServiceGetAppDetailsProps) => (
  <Get<
    RepositoriesRepoAppDetailsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceGetAppDetailsQueryParams,
    AgentRepositoryServiceGetAppDetailsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repositories/${identifier}/appdetails`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceGetAppDetailsProps = Omit<
  UseGetProps<
    RepositoriesRepoAppDetailsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceGetAppDetailsQueryParams,
    AgentRepositoryServiceGetAppDetailsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceGetAppDetailsPathParams

/**
 * GetAppDetails returns application details by given path
 *
 * GetAppDetails returns application details by given path.
 */
export const useAgentRepositoryServiceGetAppDetails = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAgentRepositoryServiceGetAppDetailsProps) =>
  useGet<
    RepositoriesRepoAppDetailsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceGetAppDetailsQueryParams,
    AgentRepositoryServiceGetAppDetailsPathParams
  >(
    (paramsInPath: AgentRepositoryServiceGetAppDetailsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/${paramsInPath.identifier}/appdetails`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentRepositoryServiceListAppsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.repo'?: string
  'query.revision'?: string
  'query.appName'?: string
  'query.appProject'?: string
}

export interface AgentRepositoryServiceListAppsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentRepositoryServiceListAppsProps = Omit<
  GetProps<
    RepositoriesRepoAppsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceListAppsQueryParams,
    AgentRepositoryServiceListAppsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceListAppsPathParams

/**
 * ListApps returns list of apps in the repo
 *
 * ListApps returns list of apps in the repo.
 */
export const AgentRepositoryServiceListApps = ({
  agentIdentifier,
  identifier,
  ...props
}: AgentRepositoryServiceListAppsProps) => (
  <Get<
    RepositoriesRepoAppsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceListAppsQueryParams,
    AgentRepositoryServiceListAppsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repositories/${identifier}/apps`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceListAppsProps = Omit<
  UseGetProps<
    RepositoriesRepoAppsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceListAppsQueryParams,
    AgentRepositoryServiceListAppsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceListAppsPathParams

/**
 * ListApps returns list of apps in the repo
 *
 * ListApps returns list of apps in the repo.
 */
export const useAgentRepositoryServiceListApps = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAgentRepositoryServiceListAppsProps) =>
  useGet<
    RepositoriesRepoAppsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceListAppsQueryParams,
    AgentRepositoryServiceListAppsPathParams
  >(
    (paramsInPath: AgentRepositoryServiceListAppsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/${paramsInPath.identifier}/apps`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentRepositoryServiceGetHelmChartsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Repo URL for query.
   */
  'query.repo'?: string
  /**
   * Whether to force a cache refresh on repo's connection state.
   */
  'query.forceRefresh'?: boolean
  /**
   * The associated project project.
   */
  'query.project'?: string
}

export interface AgentRepositoryServiceGetHelmChartsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentRepositoryServiceGetHelmChartsProps = Omit<
  GetProps<
    RepositoriesHelmChartsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceGetHelmChartsQueryParams,
    AgentRepositoryServiceGetHelmChartsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceGetHelmChartsPathParams

/**
 * GetHelmCharts returns list of helm charts in the specified repository
 *
 * GetHelmCharts returns list of helm charts in the specified repository.
 */
export const AgentRepositoryServiceGetHelmCharts = ({
  agentIdentifier,
  identifier,
  ...props
}: AgentRepositoryServiceGetHelmChartsProps) => (
  <Get<
    RepositoriesHelmChartsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceGetHelmChartsQueryParams,
    AgentRepositoryServiceGetHelmChartsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repositories/${identifier}/helmcharts`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceGetHelmChartsProps = Omit<
  UseGetProps<
    RepositoriesHelmChartsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceGetHelmChartsQueryParams,
    AgentRepositoryServiceGetHelmChartsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceGetHelmChartsPathParams

/**
 * GetHelmCharts returns list of helm charts in the specified repository
 *
 * GetHelmCharts returns list of helm charts in the specified repository.
 */
export const useAgentRepositoryServiceGetHelmCharts = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAgentRepositoryServiceGetHelmChartsProps) =>
  useGet<
    RepositoriesHelmChartsResponse,
    GatewayruntimeError,
    AgentRepositoryServiceGetHelmChartsQueryParams,
    AgentRepositoryServiceGetHelmChartsPathParams
  >(
    (paramsInPath: AgentRepositoryServiceGetHelmChartsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/${paramsInPath.identifier}/helmcharts`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentRepositoryServiceListRefsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Repo URL for query.
   */
  'query.repo'?: string
  /**
   * Whether to force a cache refresh on repo's connection state.
   */
  'query.forceRefresh'?: boolean
  /**
   * The associated project project.
   */
  'query.project'?: string
}

export interface AgentRepositoryServiceListRefsPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  identifier: string
}

export type AgentRepositoryServiceListRefsProps = Omit<
  GetProps<
    RepositoriesRefs,
    GatewayruntimeError,
    AgentRepositoryServiceListRefsQueryParams,
    AgentRepositoryServiceListRefsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceListRefsPathParams

/**
 * Returns a list of refs (e.g. branches and tags) in the repo
 *
 * Returns a list of refs (e.g. branches and tags) in the repo.
 */
export const AgentRepositoryServiceListRefs = ({
  agentIdentifier,
  identifier,
  ...props
}: AgentRepositoryServiceListRefsProps) => (
  <Get<
    RepositoriesRefs,
    GatewayruntimeError,
    AgentRepositoryServiceListRefsQueryParams,
    AgentRepositoryServiceListRefsPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/repositories/${identifier}/refs`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryServiceListRefsProps = Omit<
  UseGetProps<
    RepositoriesRefs,
    GatewayruntimeError,
    AgentRepositoryServiceListRefsQueryParams,
    AgentRepositoryServiceListRefsPathParams
  >,
  'path'
> &
  AgentRepositoryServiceListRefsPathParams

/**
 * Returns a list of refs (e.g. branches and tags) in the repo
 *
 * Returns a list of refs (e.g. branches and tags) in the repo.
 */
export const useAgentRepositoryServiceListRefs = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAgentRepositoryServiceListRefsProps) =>
  useGet<
    RepositoriesRefs,
    GatewayruntimeError,
    AgentRepositoryServiceListRefsQueryParams,
    AgentRepositoryServiceListRefsPathParams
  >(
    (paramsInPath: AgentRepositoryServiceListRefsPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/repositories/${paramsInPath.identifier}/refs`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AgentApplicationServiceWatchResponse {
  error?: RuntimeStreamError
  result?: ApplicationsApplicationWatchEvent
}

export interface AgentApplicationServiceWatchQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * the application's name.
   */
  'query.name'?: string
  /**
   * forces application reconciliation if set to true.
   */
  'query.refresh'?: string
  /**
   * the project names to restrict returned list applications.
   */
  'query.project'?: string[]
  /**
   * when specified with a watch call, shows changes that occur after that particular version of a resource.
   */
  'query.resourceVersion'?: string
  /**
   * the selector to to restrict returned list to applications only with matched labels.
   */
  'query.selector'?: string
  /**
   * the repoURL to restrict returned list applications.
   */
  'query.repo'?: string
}

export interface AgentApplicationServiceWatchPathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AgentApplicationServiceWatchProps = Omit<
  GetProps<
    AgentApplicationServiceWatchResponse,
    GatewayruntimeError,
    AgentApplicationServiceWatchQueryParams,
    AgentApplicationServiceWatchPathParams
  >,
  'path'
> &
  AgentApplicationServiceWatchPathParams

/**
 * Watch returns stream of application change events
 *
 * Watch returns stream of application change events.
 */
export const AgentApplicationServiceWatch = ({ agentIdentifier, ...props }: AgentApplicationServiceWatchProps) => (
  <Get<
    AgentApplicationServiceWatchResponse,
    GatewayruntimeError,
    AgentApplicationServiceWatchQueryParams,
    AgentApplicationServiceWatchPathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/stream/applications`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceWatchProps = Omit<
  UseGetProps<
    AgentApplicationServiceWatchResponse,
    GatewayruntimeError,
    AgentApplicationServiceWatchQueryParams,
    AgentApplicationServiceWatchPathParams
  >,
  'path'
> &
  AgentApplicationServiceWatchPathParams

/**
 * Watch returns stream of application change events
 *
 * Watch returns stream of application change events.
 */
export const useAgentApplicationServiceWatch = ({ agentIdentifier, ...props }: UseAgentApplicationServiceWatchProps) =>
  useGet<
    AgentApplicationServiceWatchResponse,
    GatewayruntimeError,
    AgentApplicationServiceWatchQueryParams,
    AgentApplicationServiceWatchPathParams
  >(
    (paramsInPath: AgentApplicationServiceWatchPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/stream/applications`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AgentApplicationServiceWatchResourceTreeResponse {
  error?: RuntimeStreamError
  result?: ApplicationsApplicationTree
}

export interface AgentApplicationServiceWatchResourceTreeQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  'query.namespace'?: string
  'query.name'?: string
  'query.version'?: string
  'query.group'?: string
  'query.kind'?: string
}

export interface AgentApplicationServiceWatchResourceTreePathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  queryApplicationName: string
}

export type AgentApplicationServiceWatchResourceTreeProps = Omit<
  GetProps<
    AgentApplicationServiceWatchResourceTreeResponse,
    GatewayruntimeError,
    AgentApplicationServiceWatchResourceTreeQueryParams,
    AgentApplicationServiceWatchResourceTreePathParams
  >,
  'path'
> &
  AgentApplicationServiceWatchResourceTreePathParams

/**
 * WatchResourceTree returns stream of application resource tree
 *
 * WatchResourceTree returns stream of application resource tree.
 */
export const AgentApplicationServiceWatchResourceTree = ({
  agentIdentifier,
  queryApplicationName,
  ...props
}: AgentApplicationServiceWatchResourceTreeProps) => (
  <Get<
    AgentApplicationServiceWatchResourceTreeResponse,
    GatewayruntimeError,
    AgentApplicationServiceWatchResourceTreeQueryParams,
    AgentApplicationServiceWatchResourceTreePathParams
  >
    path={`/api/v1/agents/${agentIdentifier}/stream/applications/${queryApplicationName}/resource-tree`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentApplicationServiceWatchResourceTreeProps = Omit<
  UseGetProps<
    AgentApplicationServiceWatchResourceTreeResponse,
    GatewayruntimeError,
    AgentApplicationServiceWatchResourceTreeQueryParams,
    AgentApplicationServiceWatchResourceTreePathParams
  >,
  'path'
> &
  AgentApplicationServiceWatchResourceTreePathParams

/**
 * WatchResourceTree returns stream of application resource tree
 *
 * WatchResourceTree returns stream of application resource tree.
 */
export const useAgentApplicationServiceWatchResourceTree = ({
  agentIdentifier,
  queryApplicationName,
  ...props
}: UseAgentApplicationServiceWatchResourceTreeProps) =>
  useGet<
    AgentApplicationServiceWatchResourceTreeResponse,
    GatewayruntimeError,
    AgentApplicationServiceWatchResourceTreeQueryParams,
    AgentApplicationServiceWatchResourceTreePathParams
  >(
    (paramsInPath: AgentApplicationServiceWatchResourceTreePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentifier}/stream/applications/${paramsInPath.queryApplicationName}/resource-tree`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, queryApplicationName }, ...props }
  )

export interface AgentServiceForServerDeleteQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  name?: string
  type?: 'AGENT_TYPE_UNSET' | 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER' | 'HOSTED_ARGO_PROVIDER'
  tags?: string[]
  searchTerm?: string
  pageSize?: number
  pageIndex?: number
  scope?: 'AGENT_SCOPE_UNSET' | 'ACCOUNT' | 'ORG' | 'PROJECT'
  drIdentifier?: string
  sortBy?: 'SORT_BY_NOT_SET' | 'NAME' | 'HEALTH_STATUS' | 'CONNECTIVITY_STATUS'
  sortOrder?: 'SORT_ORDER_NOT_SET' | 'ASC' | 'DESC'
  metadataOnly?: boolean
  ignoreScope?: boolean
}

export type AgentServiceForServerDeleteProps = Omit<
  MutateProps<V1Agent, GatewayruntimeError, AgentServiceForServerDeleteQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete agents.
 */
export const AgentServiceForServerDelete = (props: AgentServiceForServerDeleteProps) => (
  <Mutate<V1Agent, GatewayruntimeError, AgentServiceForServerDeleteQueryParams, string, void>
    verb="DELETE"
    path={`/api/v1/agents`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerDeleteProps = Omit<
  UseMutateProps<V1Agent, GatewayruntimeError, AgentServiceForServerDeleteQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete agents.
 */
export const useAgentServiceForServerDelete = (props: UseAgentServiceForServerDeleteProps) =>
  useMutate<V1Agent, GatewayruntimeError, AgentServiceForServerDeleteQueryParams, string, void>(
    'DELETE',
    `/api/v1/agents`,
    { base: window.getApiBaseUrl('gitops'), ...props }
  )

export interface AgentServiceForServerGetQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  name?: string
  type?: 'AGENT_TYPE_UNSET' | 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER' | 'HOSTED_ARGO_PROVIDER'
  tags?: string[]
  searchTerm?: string
  pageSize?: number
  pageIndex?: number
  scope?: 'AGENT_SCOPE_UNSET' | 'ACCOUNT' | 'ORG' | 'PROJECT'
  drIdentifier?: string
  sortBy?: 'SORT_BY_NOT_SET' | 'NAME' | 'HEALTH_STATUS' | 'CONNECTIVITY_STATUS'
  sortOrder?: 'SORT_ORDER_NOT_SET' | 'ASC' | 'DESC'
  metadataOnly?: boolean
  ignoreScope?: boolean
}

export interface AgentServiceForServerGetPathParams {
  identifier: string
}

export type AgentServiceForServerGetProps = Omit<
  GetProps<V1Agent, GatewayruntimeError, AgentServiceForServerGetQueryParams, AgentServiceForServerGetPathParams>,
  'path'
> &
  AgentServiceForServerGetPathParams

/**
 * Get agents.
 */
export const AgentServiceForServerGet = ({ identifier, ...props }: AgentServiceForServerGetProps) => (
  <Get<V1Agent, GatewayruntimeError, AgentServiceForServerGetQueryParams, AgentServiceForServerGetPathParams>
    path={`/api/v1/agents/${identifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerGetProps = Omit<
  UseGetProps<V1Agent, GatewayruntimeError, AgentServiceForServerGetQueryParams, AgentServiceForServerGetPathParams>,
  'path'
> &
  AgentServiceForServerGetPathParams

/**
 * Get agents.
 */
export const useAgentServiceForServerGet = ({ identifier, ...props }: UseAgentServiceForServerGetProps) =>
  useGet<V1Agent, GatewayruntimeError, AgentServiceForServerGetQueryParams, AgentServiceForServerGetPathParams>(
    (paramsInPath: AgentServiceForServerGetPathParams) => `/api/v1/agents/${paramsInPath.identifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { identifier }, ...props }
  )

export interface AgentServiceForServerRegenerateCredentialsPathParams {
  identifier: string
}

export type AgentServiceForServerRegenerateCredentialsProps = Omit<
  MutateProps<V1Agent, GatewayruntimeError, void, void, AgentServiceForServerRegenerateCredentialsPathParams>,
  'path' | 'verb'
> &
  AgentServiceForServerRegenerateCredentialsPathParams

/**
 * Regenerate credentials for agents.
 */
export const AgentServiceForServerRegenerateCredentials = ({
  identifier,
  ...props
}: AgentServiceForServerRegenerateCredentialsProps) => (
  <Mutate<V1Agent, GatewayruntimeError, void, void, AgentServiceForServerRegenerateCredentialsPathParams>
    verb="POST"
    path={`/api/v1/agents/${identifier}/credentials`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerRegenerateCredentialsProps = Omit<
  UseMutateProps<V1Agent, GatewayruntimeError, void, void, AgentServiceForServerRegenerateCredentialsPathParams>,
  'path' | 'verb'
> &
  AgentServiceForServerRegenerateCredentialsPathParams

/**
 * Regenerate credentials for agents.
 */
export const useAgentServiceForServerRegenerateCredentials = ({
  identifier,
  ...props
}: UseAgentServiceForServerRegenerateCredentialsProps) =>
  useMutate<V1Agent, GatewayruntimeError, void, void, AgentServiceForServerRegenerateCredentialsPathParams>(
    'POST',
    (paramsInPath: AgentServiceForServerRegenerateCredentialsPathParams) =>
      `/api/v1/agents/${paramsInPath.identifier}/credentials`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { identifier }, ...props }
  )

export interface AgentServiceForServerScalePathParams {
  identifier: string
}

export type AgentServiceForServerScaleProps = Omit<
  MutateProps<V1Agent, GatewayruntimeError, void, V1AgentScaleRequest, AgentServiceForServerScalePathParams>,
  'path' | 'verb'
> &
  AgentServiceForServerScalePathParams

/**
 * Scale the Hosted agent.
 */
export const AgentServiceForServerScale = ({ identifier, ...props }: AgentServiceForServerScaleProps) => (
  <Mutate<V1Agent, GatewayruntimeError, void, V1AgentScaleRequest, AgentServiceForServerScalePathParams>
    verb="POST"
    path={`/api/v1/agents/${identifier}/scale`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerScaleProps = Omit<
  UseMutateProps<V1Agent, GatewayruntimeError, void, V1AgentScaleRequest, AgentServiceForServerScalePathParams>,
  'path' | 'verb'
> &
  AgentServiceForServerScalePathParams

/**
 * Scale the Hosted agent.
 */
export const useAgentServiceForServerScale = ({ identifier, ...props }: UseAgentServiceForServerScaleProps) =>
  useMutate<V1Agent, GatewayruntimeError, void, V1AgentScaleRequest, AgentServiceForServerScalePathParams>(
    'POST',
    (paramsInPath: AgentServiceForServerScalePathParams) => `/api/v1/agents/${paramsInPath.identifier}/scale`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { identifier }, ...props }
  )

export interface AgentServiceForServerUniqueQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  name?: string
  type?: 'AGENT_TYPE_UNSET' | 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER' | 'HOSTED_ARGO_PROVIDER'
  tags?: string[]
  searchTerm?: string
  pageSize?: number
  pageIndex?: number
  scope?: 'AGENT_SCOPE_UNSET' | 'ACCOUNT' | 'ORG' | 'PROJECT'
  drIdentifier?: string
  sortBy?: 'SORT_BY_NOT_SET' | 'NAME' | 'HEALTH_STATUS' | 'CONNECTIVITY_STATUS'
  sortOrder?: 'SORT_ORDER_NOT_SET' | 'ASC' | 'DESC'
  metadataOnly?: boolean
  ignoreScope?: boolean
}

export interface AgentServiceForServerUniquePathParams {
  identifier: string
}

export type AgentServiceForServerUniqueProps = Omit<
  GetProps<
    V1UniqueMessage,
    GatewayruntimeError,
    AgentServiceForServerUniqueQueryParams,
    AgentServiceForServerUniquePathParams
  >,
  'path'
> &
  AgentServiceForServerUniquePathParams

/**
 * Unique returns unique agents.
 */
export const AgentServiceForServerUnique = ({ identifier, ...props }: AgentServiceForServerUniqueProps) => (
  <Get<
    V1UniqueMessage,
    GatewayruntimeError,
    AgentServiceForServerUniqueQueryParams,
    AgentServiceForServerUniquePathParams
  >
    path={`/api/v1/agents/${identifier}/unique`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentServiceForServerUniqueProps = Omit<
  UseGetProps<
    V1UniqueMessage,
    GatewayruntimeError,
    AgentServiceForServerUniqueQueryParams,
    AgentServiceForServerUniquePathParams
  >,
  'path'
> &
  AgentServiceForServerUniquePathParams

/**
 * Unique returns unique agents.
 */
export const useAgentServiceForServerUnique = ({ identifier, ...props }: UseAgentServiceForServerUniqueProps) =>
  useGet<
    V1UniqueMessage,
    GatewayruntimeError,
    AgentServiceForServerUniqueQueryParams,
    AgentServiceForServerUniquePathParams
  >((paramsInPath: AgentServiceForServerUniquePathParams) => `/api/v1/agents/${paramsInPath.identifier}/unique`, {
    base: window.getApiBaseUrl('gitops'),
    pathParams: { identifier },
    ...props
  })

export type ApplicationServiceListAppsProps = Omit<
  MutateProps<Servicev1Applicationlist, GatewayruntimeError, void, Servicev1ApplicationQuery, void>,
  'path' | 'verb'
>

/**
 * List returns list of apps
 */
export const ApplicationServiceListApps = (props: ApplicationServiceListAppsProps) => (
  <Mutate<Servicev1Applicationlist, GatewayruntimeError, void, Servicev1ApplicationQuery, void>
    verb="POST"
    path={`/api/v1/applications`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseApplicationServiceListAppsProps = Omit<
  UseMutateProps<Servicev1Applicationlist, GatewayruntimeError, void, Servicev1ApplicationQuery, void>,
  'path' | 'verb'
>

/**
 * List returns list of apps
 */
export const useApplicationServiceListApps = (props: UseApplicationServiceListAppsProps) =>
  useMutate<Servicev1Applicationlist, GatewayruntimeError, void, Servicev1ApplicationQuery, void>(
    'POST',
    `/api/v1/applications`,
    { base: window.getApiBaseUrl('gitops'), ...props }
  )

export type ApplicationServiceListAppSyncProps = Omit<
  MutateProps<V1ApplicationSyncStatuslist, GatewayruntimeError, void, V1ApplicationSyncStatusQuery, void>,
  'path' | 'verb'
>

/**
 * List returns list of application sync status
 *
 * List returns list of application sync status
 */
export const ApplicationServiceListAppSync = (props: ApplicationServiceListAppSyncProps) => (
  <Mutate<V1ApplicationSyncStatuslist, GatewayruntimeError, void, V1ApplicationSyncStatusQuery, void>
    verb="POST"
    path={`/api/v1/applications/sync`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseApplicationServiceListAppSyncProps = Omit<
  UseMutateProps<V1ApplicationSyncStatuslist, GatewayruntimeError, void, V1ApplicationSyncStatusQuery, void>,
  'path' | 'verb'
>

/**
 * List returns list of application sync status
 *
 * List returns list of application sync status
 */
export const useApplicationServiceListAppSync = (props: UseApplicationServiceListAppSyncProps) =>
  useMutate<V1ApplicationSyncStatuslist, GatewayruntimeError, void, V1ApplicationSyncStatusQuery, void>(
    'POST',
    `/api/v1/applications/sync`,
    { base: window.getApiBaseUrl('gitops'), ...props }
  )

export interface ApplicationServiceExistsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
}

export interface ApplicationServiceExistsPathParams {
  name: string
}

export type ApplicationServiceExistsProps = Omit<
  GetProps<boolean, GatewayruntimeError, ApplicationServiceExistsQueryParams, ApplicationServiceExistsPathParams>,
  'path'
> &
  ApplicationServiceExistsPathParams

/**
 * Checks whether an app with the given name exists
 *
 * Checks whether an app with the given name exists
 */
export const ApplicationServiceExists = ({ name, ...props }: ApplicationServiceExistsProps) => (
  <Get<boolean, GatewayruntimeError, ApplicationServiceExistsQueryParams, ApplicationServiceExistsPathParams>
    path={`/api/v1/applications/${name}/exists`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseApplicationServiceExistsProps = Omit<
  UseGetProps<boolean, GatewayruntimeError, ApplicationServiceExistsQueryParams, ApplicationServiceExistsPathParams>,
  'path'
> &
  ApplicationServiceExistsPathParams

/**
 * Checks whether an app with the given name exists
 *
 * Checks whether an app with the given name exists
 */
export const useApplicationServiceExists = ({ name, ...props }: UseApplicationServiceExistsProps) =>
  useGet<boolean, GatewayruntimeError, ApplicationServiceExistsQueryParams, ApplicationServiceExistsPathParams>(
    (paramsInPath: ApplicationServiceExistsPathParams) => `/api/v1/applications/${paramsInPath.name}/exists`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { name }, ...props }
  )

export interface AppProjectMappingServiceGetAppProjectMappingListQueryParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export type AppProjectMappingServiceGetAppProjectMappingListProps = Omit<
  GetProps<
    Servicev1AppProjectMapping,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingListQueryParams,
    void
  >,
  'path'
>

/**
 * Retrieves Harness-Argo project mappings list.
 */
export const AppProjectMappingServiceGetAppProjectMappingList = (
  props: AppProjectMappingServiceGetAppProjectMappingListProps
) => (
  <Get<
    Servicev1AppProjectMapping,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingListQueryParams,
    void
  >
    path={`/api/v1/appprojectsmapping`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAppProjectMappingServiceGetAppProjectMappingListProps = Omit<
  UseGetProps<
    Servicev1AppProjectMapping,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingListQueryParams,
    void
  >,
  'path'
>

/**
 * Retrieves Harness-Argo project mappings list.
 */
export const useAppProjectMappingServiceGetAppProjectMappingList = (
  props: UseAppProjectMappingServiceGetAppProjectMappingListProps
) =>
  useGet<
    Servicev1AppProjectMapping,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingListQueryParams,
    void
  >(`/api/v1/appprojectsmapping`, { base: window.getApiBaseUrl('gitops'), ...props })

export interface CertificateServiceListCertsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  name?: string
  searchTerm?: string
  pageSize?: number
  pageIndex?: number
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
}

export type CertificateServiceListCertsProps = Omit<
  GetProps<V1Certificatelist, GatewayruntimeError, CertificateServiceListCertsQueryParams, void>,
  'path'
>

/**
 * List returns list of certificates
 *
 * List returns list of certificates
 */
export const CertificateServiceListCerts = (props: CertificateServiceListCertsProps) => (
  <Get<V1Certificatelist, GatewayruntimeError, CertificateServiceListCertsQueryParams, void>
    path={`/api/v1/certificates`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseCertificateServiceListCertsProps = Omit<
  UseGetProps<V1Certificatelist, GatewayruntimeError, CertificateServiceListCertsQueryParams, void>,
  'path'
>

/**
 * List returns list of certificates
 *
 * List returns list of certificates
 */
export const useCertificateServiceListCerts = (props: UseCertificateServiceListCertsProps) =>
  useGet<V1Certificatelist, GatewayruntimeError, CertificateServiceListCertsQueryParams, void>(`/api/v1/certificates`, {
    base: window.getApiBaseUrl('gitops'),
    ...props
  })

export type ClusterServiceListClustersProps = Omit<
  MutateProps<V1Clusterlist, GatewayruntimeError, void, Servicev1ClusterQuery, void>,
  'path' | 'verb'
>

/**
 * List returns list of Clusters
 *
 * List returns list of Clusters
 */
export const ClusterServiceListClusters = (props: ClusterServiceListClustersProps) => (
  <Mutate<V1Clusterlist, GatewayruntimeError, void, Servicev1ClusterQuery, void>
    verb="POST"
    path={`/api/v1/clusters`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseClusterServiceListClustersProps = Omit<
  UseMutateProps<V1Clusterlist, GatewayruntimeError, void, Servicev1ClusterQuery, void>,
  'path' | 'verb'
>

/**
 * List returns list of Clusters
 *
 * List returns list of Clusters
 */
export const useClusterServiceListClusters = (props: UseClusterServiceListClustersProps) =>
  useMutate<V1Clusterlist, GatewayruntimeError, void, Servicev1ClusterQuery, void>('POST', `/api/v1/clusters`, {
    base: window.getApiBaseUrl('gitops'),
    ...props
  })

export interface ClusterServiceExistsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  server?: string
}

export type ClusterServiceExistsProps = Omit<
  GetProps<boolean, GatewayruntimeError, ClusterServiceExistsQueryParams, void>,
  'path'
>

/**
 * Checks for whether the cluster exists
 *
 * Checks for whether the cluster exists
 */
export const ClusterServiceExists = (props: ClusterServiceExistsProps) => (
  <Get<boolean, GatewayruntimeError, ClusterServiceExistsQueryParams, void>
    path={`/api/v1/clusters/exists`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseClusterServiceExistsProps = Omit<
  UseGetProps<boolean, GatewayruntimeError, ClusterServiceExistsQueryParams, void>,
  'path'
>

/**
 * Checks for whether the cluster exists
 *
 * Checks for whether the cluster exists
 */
export const useClusterServiceExists = (props: UseClusterServiceExistsProps) =>
  useGet<boolean, GatewayruntimeError, ClusterServiceExistsQueryParams, void>(`/api/v1/clusters/exists`, {
    base: window.getApiBaseUrl('gitops'),
    ...props
  })

export type DashboardServiceRecentDeploymentsProps = Omit<
  MutateProps<V1RecentDeploymentsDetailsList, GatewayruntimeError, void, V1RecentDeploymentQuery, void>,
  'path' | 'verb'
>

/**
 * Returns aggregate statistics of recent deployments
 *
 * Returns aggregate statistics of recent deployments
 */
export const DashboardServiceRecentDeployments = (props: DashboardServiceRecentDeploymentsProps) => (
  <Mutate<V1RecentDeploymentsDetailsList, GatewayruntimeError, void, V1RecentDeploymentQuery, void>
    verb="POST"
    path={`/api/v1/dashboard/activity`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseDashboardServiceRecentDeploymentsProps = Omit<
  UseMutateProps<V1RecentDeploymentsDetailsList, GatewayruntimeError, void, V1RecentDeploymentQuery, void>,
  'path' | 'verb'
>

/**
 * Returns aggregate statistics of recent deployments
 *
 * Returns aggregate statistics of recent deployments
 */
export const useDashboardServiceRecentDeployments = (props: UseDashboardServiceRecentDeploymentsProps) =>
  useMutate<V1RecentDeploymentsDetailsList, GatewayruntimeError, void, V1RecentDeploymentQuery, void>(
    'POST',
    `/api/v1/dashboard/activity`,
    { base: window.getApiBaseUrl('gitops'), ...props }
  )

export interface DashboardServiceRecentlyCreatedCountsQueryParams {
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  endTime?: number
  startTime?: number
}

export type DashboardServiceRecentlyCreatedCountsProps = Omit<
  GetProps<V1RecentlyCreatedOverview, GatewayruntimeError, DashboardServiceRecentlyCreatedCountsQueryParams, void>,
  'path'
>

/**
 * List count of Cluster, Repos and Apps created within a time series
 *
 * List count of Cluster, Repos and Apps created within a time series.
 */
export const DashboardServiceRecentlyCreatedCounts = (props: DashboardServiceRecentlyCreatedCountsProps) => (
  <Get<V1RecentlyCreatedOverview, GatewayruntimeError, DashboardServiceRecentlyCreatedCountsQueryParams, void>
    path={`/api/v1/dashboard/counts`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseDashboardServiceRecentlyCreatedCountsProps = Omit<
  UseGetProps<V1RecentlyCreatedOverview, GatewayruntimeError, DashboardServiceRecentlyCreatedCountsQueryParams, void>,
  'path'
>

/**
 * List count of Cluster, Repos and Apps created within a time series
 *
 * List count of Cluster, Repos and Apps created within a time series.
 */
export const useDashboardServiceRecentlyCreatedCounts = (props: UseDashboardServiceRecentlyCreatedCountsProps) =>
  useGet<V1RecentlyCreatedOverview, GatewayruntimeError, DashboardServiceRecentlyCreatedCountsQueryParams, void>(
    `/api/v1/dashboard/counts`,
    { base: window.getApiBaseUrl('gitops'), ...props }
  )

export interface DashboardServiceGetDashboardOverviewQueryParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  disasterRecoveryIdentifier?: string
}

export type DashboardServiceGetDashboardOverviewProps = Omit<
  GetProps<V1DashboardOverview, GatewayruntimeError, DashboardServiceGetDashboardOverviewQueryParams, void>,
  'path'
>

/**
 * GetDashboradOverview gets dashboard overview
 *
 * Gets dashboard overview
 */
export const DashboardServiceGetDashboardOverview = (props: DashboardServiceGetDashboardOverviewProps) => (
  <Get<V1DashboardOverview, GatewayruntimeError, DashboardServiceGetDashboardOverviewQueryParams, void>
    path={`/api/v1/dashboard/overview`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseDashboardServiceGetDashboardOverviewProps = Omit<
  UseGetProps<V1DashboardOverview, GatewayruntimeError, DashboardServiceGetDashboardOverviewQueryParams, void>,
  'path'
>

/**
 * GetDashboradOverview gets dashboard overview
 *
 * Gets dashboard overview
 */
export const useDashboardServiceGetDashboardOverview = (props: UseDashboardServiceGetDashboardOverviewProps) =>
  useGet<V1DashboardOverview, GatewayruntimeError, DashboardServiceGetDashboardOverviewQueryParams, void>(
    `/api/v1/dashboard/overview`,
    { base: window.getApiBaseUrl('gitops'), ...props }
  )

export interface DashboardServiceTopApplicationPhaseStatsQueryParams {
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  endTime?: number
  startTime?: number
  limit?: number
}

export type DashboardServiceTopApplicationPhaseStatsProps = Omit<
  GetProps<
    V1TopApplicationPhaseStatsList,
    GatewayruntimeError,
    DashboardServiceTopApplicationPhaseStatsQueryParams,
    void
  >,
  'path'
>

/**
 * List phase status counts for top 5 most deployed apps
 *
 * List phase status counts for top 5 most deployed apps
 */
export const DashboardServiceTopApplicationPhaseStats = (props: DashboardServiceTopApplicationPhaseStatsProps) => (
  <Get<V1TopApplicationPhaseStatsList, GatewayruntimeError, DashboardServiceTopApplicationPhaseStatsQueryParams, void>
    path={`/api/v1/dashboard/topapps`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseDashboardServiceTopApplicationPhaseStatsProps = Omit<
  UseGetProps<
    V1TopApplicationPhaseStatsList,
    GatewayruntimeError,
    DashboardServiceTopApplicationPhaseStatsQueryParams,
    void
  >,
  'path'
>

/**
 * List phase status counts for top 5 most deployed apps
 *
 * List phase status counts for top 5 most deployed apps
 */
export const useDashboardServiceTopApplicationPhaseStats = (props: UseDashboardServiceTopApplicationPhaseStatsProps) =>
  useGet<
    V1TopApplicationPhaseStatsList,
    GatewayruntimeError,
    DashboardServiceTopApplicationPhaseStatsQueryParams,
    void
  >(`/api/v1/dashboard/topapps`, { base: window.getApiBaseUrl('gitops'), ...props })

export interface GnuPGKeyServiceListGPGKeysQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  gnuPG?: string
  searchTerm?: string
  pageSize?: number
  pageIndex?: number
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
}

export type GnuPGKeyServiceListGPGKeysProps = Omit<
  GetProps<Servicev1GnuPGPublicKeyList, GatewayruntimeError, GnuPGKeyServiceListGPGKeysQueryParams, void>,
  'path'
>

/**
 * List all available repository certificates
 *
 * List all available repository certificates
 */
export const GnuPGKeyServiceListGPGKeys = (props: GnuPGKeyServiceListGPGKeysProps) => (
  <Get<Servicev1GnuPGPublicKeyList, GatewayruntimeError, GnuPGKeyServiceListGPGKeysQueryParams, void>
    path={`/api/v1/gpgkeys`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseGnuPGKeyServiceListGPGKeysProps = Omit<
  UseGetProps<Servicev1GnuPGPublicKeyList, GatewayruntimeError, GnuPGKeyServiceListGPGKeysQueryParams, void>,
  'path'
>

/**
 * List all available repository certificates
 *
 * List all available repository certificates
 */
export const useGnuPGKeyServiceListGPGKeys = (props: UseGnuPGKeyServiceListGPGKeysProps) =>
  useGet<Servicev1GnuPGPublicKeyList, GatewayruntimeError, GnuPGKeyServiceListGPGKeysQueryParams, void>(
    `/api/v1/gpgkeys`,
    { base: window.getApiBaseUrl('gitops'), ...props }
  )

export type AgentRepositoryCredentialsServiceListRepositoryCredentialsProps = Omit<
  MutateProps<Servicev1RepositoryCredentialsList, GatewayruntimeError, void, V1RepositoryCredentialsQuery, void>,
  'path' | 'verb'
>

/**
 * List repository credentials
 *
 * List repository credentials.
 */
export const AgentRepositoryCredentialsServiceListRepositoryCredentials = (
  props: AgentRepositoryCredentialsServiceListRepositoryCredentialsProps
) => (
  <Mutate<Servicev1RepositoryCredentialsList, GatewayruntimeError, void, V1RepositoryCredentialsQuery, void>
    verb="POST"
    path={`/api/v1/repocreds`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAgentRepositoryCredentialsServiceListRepositoryCredentialsProps = Omit<
  UseMutateProps<Servicev1RepositoryCredentialsList, GatewayruntimeError, void, V1RepositoryCredentialsQuery, void>,
  'path' | 'verb'
>

/**
 * List repository credentials
 *
 * List repository credentials.
 */
export const useAgentRepositoryCredentialsServiceListRepositoryCredentials = (
  props: UseAgentRepositoryCredentialsServiceListRepositoryCredentialsProps
) =>
  useMutate<Servicev1RepositoryCredentialsList, GatewayruntimeError, void, V1RepositoryCredentialsQuery, void>(
    'POST',
    `/api/v1/repocreds`,
    { base: window.getApiBaseUrl('gitops'), ...props }
  )

export interface RepositoryServiceListRepositoriesByRepositoryCredentialTemplateQueryParams {
  repositoryCredentialURL?: string
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  pageSize?: number
  pageIndex?: number
}

export type RepositoryServiceListRepositoriesByRepositoryCredentialTemplateProps = Omit<
  GetProps<
    V1Repositorylist,
    GatewayruntimeError,
    RepositoryServiceListRepositoriesByRepositoryCredentialTemplateQueryParams,
    void
  >,
  'path'
>

/**
 * List returns list of Repositories by repository credential template
 *
 * List returns list of Repositories by repositories credential template
 */
export const RepositoryServiceListRepositoriesByRepositoryCredentialTemplate = (
  props: RepositoryServiceListRepositoriesByRepositoryCredentialTemplateProps
) => (
  <Get<
    V1Repositorylist,
    GatewayruntimeError,
    RepositoryServiceListRepositoriesByRepositoryCredentialTemplateQueryParams,
    void
  >
    path={`/api/v1/repositories`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseRepositoryServiceListRepositoriesByRepositoryCredentialTemplateProps = Omit<
  UseGetProps<
    V1Repositorylist,
    GatewayruntimeError,
    RepositoryServiceListRepositoriesByRepositoryCredentialTemplateQueryParams,
    void
  >,
  'path'
>

/**
 * List returns list of Repositories by repository credential template
 *
 * List returns list of Repositories by repositories credential template
 */
export const useRepositoryServiceListRepositoriesByRepositoryCredentialTemplate = (
  props: UseRepositoryServiceListRepositoriesByRepositoryCredentialTemplateProps
) =>
  useGet<
    V1Repositorylist,
    GatewayruntimeError,
    RepositoryServiceListRepositoriesByRepositoryCredentialTemplateQueryParams,
    void
  >(`/api/v1/repositories`, { base: window.getApiBaseUrl('gitops'), ...props })

export type RepositoryServiceListRepositoriesProps = Omit<
  MutateProps<V1Repositorylist, GatewayruntimeError, void, V1RepoListReq, void>,
  'path' | 'verb'
>

/**
 * List returns list of Repositories
 *
 * List returns list of Repositories
 */
export const RepositoryServiceListRepositories = (props: RepositoryServiceListRepositoriesProps) => (
  <Mutate<V1Repositorylist, GatewayruntimeError, void, V1RepoListReq, void>
    verb="POST"
    path={`/api/v1/repositories`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseRepositoryServiceListRepositoriesProps = Omit<
  UseMutateProps<V1Repositorylist, GatewayruntimeError, void, V1RepoListReq, void>,
  'path' | 'verb'
>

/**
 * List returns list of Repositories
 *
 * List returns list of Repositories
 */
export const useRepositoryServiceListRepositories = (props: UseRepositoryServiceListRepositoriesProps) =>
  useMutate<V1Repositorylist, GatewayruntimeError, void, V1RepoListReq, void>('POST', `/api/v1/repositories`, {
    base: window.getApiBaseUrl('gitops'),
    ...props
  })

export interface RepositoryServiceExistsQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  /**
   * Agent identifier for entity.
   */
  agentIdentifier?: string
  url?: string
}

export type RepositoryServiceExistsProps = Omit<
  GetProps<boolean, GatewayruntimeError, RepositoryServiceExistsQueryParams, void>,
  'path'
>

/**
 * Checks whether a repository with the given name exists
 *
 * Checks whether a repository with the given name exists.
 */
export const RepositoryServiceExists = (props: RepositoryServiceExistsProps) => (
  <Get<boolean, GatewayruntimeError, RepositoryServiceExistsQueryParams, void>
    path={`/api/v1/repositories/exists`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseRepositoryServiceExistsProps = Omit<
  UseGetProps<boolean, GatewayruntimeError, RepositoryServiceExistsQueryParams, void>,
  'path'
>

/**
 * Checks whether a repository with the given name exists
 *
 * Checks whether a repository with the given name exists.
 */
export const useRepositoryServiceExists = (props: UseRepositoryServiceExistsProps) =>
  useGet<boolean, GatewayruntimeError, RepositoryServiceExistsQueryParams, void>(`/api/v1/repositories/exists`, {
    base: window.getApiBaseUrl('gitops'),
    ...props
  })

export interface AppProjectMappingServiceCreateV2PathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AppProjectMappingServiceCreateV2Props = Omit<
  MutateProps<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    void,
    V1AppProjectMappingCreateRequestV2,
    AppProjectMappingServiceCreateV2PathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceCreateV2PathParams

/**
 * CreateAppProjectMapping creates a new mapping between Harness Project and argo project
 *
 * Creates Harness-Argo project mappings.
 */
export const AppProjectMappingServiceCreateV2 = ({
  agentIdentifier,
  ...props
}: AppProjectMappingServiceCreateV2Props) => (
  <Mutate<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    void,
    V1AppProjectMappingCreateRequestV2,
    AppProjectMappingServiceCreateV2PathParams
  >
    verb="POST"
    path={`/api/v2/agents/${agentIdentifier}/appprojectsmapping`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAppProjectMappingServiceCreateV2Props = Omit<
  UseMutateProps<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    void,
    V1AppProjectMappingCreateRequestV2,
    AppProjectMappingServiceCreateV2PathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceCreateV2PathParams

/**
 * CreateAppProjectMapping creates a new mapping between Harness Project and argo project
 *
 * Creates Harness-Argo project mappings.
 */
export const useAppProjectMappingServiceCreateV2 = ({
  agentIdentifier,
  ...props
}: UseAppProjectMappingServiceCreateV2Props) =>
  useMutate<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    void,
    V1AppProjectMappingCreateRequestV2,
    AppProjectMappingServiceCreateV2PathParams
  >(
    'POST',
    (paramsInPath: AppProjectMappingServiceCreateV2PathParams) =>
      `/api/v2/agents/${paramsInPath.agentIdentifier}/appprojectsmapping`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AppProjectMappingServiceDeleteV2QueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
}

export interface AppProjectMappingServiceDeleteV2PathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AppProjectMappingServiceDeleteV2Props = Omit<
  MutateProps<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceDeleteV2QueryParams,
    string,
    AppProjectMappingServiceDeleteV2PathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceDeleteV2PathParams

/**
 * Delete an argo project to harness project mapping
 *
 * Delete Harness-Argo project mappings.
 */
export const AppProjectMappingServiceDeleteV2 = ({
  agentIdentifier,
  ...props
}: AppProjectMappingServiceDeleteV2Props) => (
  <Mutate<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceDeleteV2QueryParams,
    string,
    AppProjectMappingServiceDeleteV2PathParams
  >
    verb="DELETE"
    path={`/api/v2/agents/${agentIdentifier}/appprojectsmapping`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAppProjectMappingServiceDeleteV2Props = Omit<
  UseMutateProps<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceDeleteV2QueryParams,
    string,
    AppProjectMappingServiceDeleteV2PathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceDeleteV2PathParams

/**
 * Delete an argo project to harness project mapping
 *
 * Delete Harness-Argo project mappings.
 */
export const useAppProjectMappingServiceDeleteV2 = ({
  agentIdentifier,
  ...props
}: UseAppProjectMappingServiceDeleteV2Props) =>
  useMutate<
    Servicev1Empty,
    GatewayruntimeError,
    AppProjectMappingServiceDeleteV2QueryParams,
    string,
    AppProjectMappingServiceDeleteV2PathParams
  >(
    'DELETE',
    (paramsInPath: AppProjectMappingServiceDeleteV2PathParams) =>
      `/api/v2/agents/${paramsInPath.agentIdentifier}/appprojectsmapping`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )

export interface AppProjectMappingServiceGetAppProjectMappingV2QueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  argoProjectName?: string
}

export interface AppProjectMappingServiceGetAppProjectMappingV2PathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  /**
   * app project mapping identifier.
   */
  identifier: string
}

export type AppProjectMappingServiceGetAppProjectMappingV2Props = Omit<
  GetProps<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingV2QueryParams,
    AppProjectMappingServiceGetAppProjectMappingV2PathParams
  >,
  'path'
> &
  AppProjectMappingServiceGetAppProjectMappingV2PathParams

/**
 * Retrieves Harness-Argo project mapping for the given identifier.
 */
export const AppProjectMappingServiceGetAppProjectMappingV2 = ({
  agentIdentifier,
  identifier,
  ...props
}: AppProjectMappingServiceGetAppProjectMappingV2Props) => (
  <Get<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingV2QueryParams,
    AppProjectMappingServiceGetAppProjectMappingV2PathParams
  >
    path={`/api/v2/agents/${agentIdentifier}/appprojectsmapping/${identifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAppProjectMappingServiceGetAppProjectMappingV2Props = Omit<
  UseGetProps<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingV2QueryParams,
    AppProjectMappingServiceGetAppProjectMappingV2PathParams
  >,
  'path'
> &
  AppProjectMappingServiceGetAppProjectMappingV2PathParams

/**
 * Retrieves Harness-Argo project mapping for the given identifier.
 */
export const useAppProjectMappingServiceGetAppProjectMappingV2 = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAppProjectMappingServiceGetAppProjectMappingV2Props) =>
  useGet<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingV2QueryParams,
    AppProjectMappingServiceGetAppProjectMappingV2PathParams
  >(
    (paramsInPath: AppProjectMappingServiceGetAppProjectMappingV2PathParams) =>
      `/api/v2/agents/${paramsInPath.agentIdentifier}/appprojectsmapping/${paramsInPath.identifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AppProjectMappingServiceUpdateV2PathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
  /**
   * app project mapping identifier.
   */
  identifier: string
}

export type AppProjectMappingServiceUpdateV2Props = Omit<
  MutateProps<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    void,
    V1AppProjectMappingQueryV2,
    AppProjectMappingServiceUpdateV2PathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceUpdateV2PathParams

/**
 * CreateAppProjectMapping creates a new mapping between Harness Project and argo project
 *
 * Creates Harness-Argo project mappings.
 */
export const AppProjectMappingServiceUpdateV2 = ({
  agentIdentifier,
  identifier,
  ...props
}: AppProjectMappingServiceUpdateV2Props) => (
  <Mutate<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    void,
    V1AppProjectMappingQueryV2,
    AppProjectMappingServiceUpdateV2PathParams
  >
    verb="PUT"
    path={`/api/v2/agents/${agentIdentifier}/appprojectsmapping/${identifier}`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAppProjectMappingServiceUpdateV2Props = Omit<
  UseMutateProps<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    void,
    V1AppProjectMappingQueryV2,
    AppProjectMappingServiceUpdateV2PathParams
  >,
  'path' | 'verb'
> &
  AppProjectMappingServiceUpdateV2PathParams

/**
 * CreateAppProjectMapping creates a new mapping between Harness Project and argo project
 *
 * Creates Harness-Argo project mappings.
 */
export const useAppProjectMappingServiceUpdateV2 = ({
  agentIdentifier,
  identifier,
  ...props
}: UseAppProjectMappingServiceUpdateV2Props) =>
  useMutate<
    V1AppProjectMappingV2,
    GatewayruntimeError,
    void,
    V1AppProjectMappingQueryV2,
    AppProjectMappingServiceUpdateV2PathParams
  >(
    'PUT',
    (paramsInPath: AppProjectMappingServiceUpdateV2PathParams) =>
      `/api/v2/agents/${paramsInPath.agentIdentifier}/appprojectsmapping/${paramsInPath.identifier}`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier, identifier }, ...props }
  )

export interface AppProjectMappingServiceGetAppProjectMappingsListByAgentV2QueryParams {
  /**
   * app project mapping identifier.
   */
  identifier?: string
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier?: string
  /**
   * Organization Identifier for the Entity.
   */
  orgIdentifier?: string
  /**
   * Project Identifier for the Entity.
   */
  projectIdentifier?: string
  argoProjectName?: string
}

export interface AppProjectMappingServiceGetAppProjectMappingsListByAgentV2PathParams {
  /**
   * Agent identifier for entity.
   */
  agentIdentifier: string
}

export type AppProjectMappingServiceGetAppProjectMappingsListByAgentV2Props = Omit<
  GetProps<
    V1AppProjectMappingV2List,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingsListByAgentV2QueryParams,
    AppProjectMappingServiceGetAppProjectMappingsListByAgentV2PathParams
  >,
  'path'
> &
  AppProjectMappingServiceGetAppProjectMappingsListByAgentV2PathParams

/**
 * V2
 *
 * Retrieves Harness-Argo project mappings list by agent.
 */
export const AppProjectMappingServiceGetAppProjectMappingsListByAgentV2 = ({
  agentIdentifier,
  ...props
}: AppProjectMappingServiceGetAppProjectMappingsListByAgentV2Props) => (
  <Get<
    V1AppProjectMappingV2List,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingsListByAgentV2QueryParams,
    AppProjectMappingServiceGetAppProjectMappingsListByAgentV2PathParams
  >
    path={`/api/v2/agents/${agentIdentifier}/appprojectsmappings`}
    base={window.getApiBaseUrl('gitops')}
    {...props}
  />
)

export type UseAppProjectMappingServiceGetAppProjectMappingsListByAgentV2Props = Omit<
  UseGetProps<
    V1AppProjectMappingV2List,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingsListByAgentV2QueryParams,
    AppProjectMappingServiceGetAppProjectMappingsListByAgentV2PathParams
  >,
  'path'
> &
  AppProjectMappingServiceGetAppProjectMappingsListByAgentV2PathParams

/**
 * V2
 *
 * Retrieves Harness-Argo project mappings list by agent.
 */
export const useAppProjectMappingServiceGetAppProjectMappingsListByAgentV2 = ({
  agentIdentifier,
  ...props
}: UseAppProjectMappingServiceGetAppProjectMappingsListByAgentV2Props) =>
  useGet<
    V1AppProjectMappingV2List,
    GatewayruntimeError,
    AppProjectMappingServiceGetAppProjectMappingsListByAgentV2QueryParams,
    AppProjectMappingServiceGetAppProjectMappingsListByAgentV2PathParams
  >(
    (paramsInPath: AppProjectMappingServiceGetAppProjectMappingsListByAgentV2PathParams) =>
      `/api/v2/agents/${paramsInPath.agentIdentifier}/appprojectsmappings`,
    { base: window.getApiBaseUrl('gitops'), pathParams: { agentIdentifier }, ...props }
  )
